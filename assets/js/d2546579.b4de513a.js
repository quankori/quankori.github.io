"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[49],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=i,g=u["".concat(s,".").concat(d)]||u[d]||m[d]||r;return n?a.createElement(g,o(o({ref:t},p),{},{components:n})):a.createElement(g,o({ref:t},p))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2965:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const r={title:"SQL Optimization"},o=void 0,l={unversionedId:"cheatsheet/database/sql-optimize",id:"cheatsheet/database/sql-optimize",title:"SQL Optimization",description:"1. Mastering JOINs for Enhanced Performance",source:"@site/docs/cheatsheet/database/sql-optimize.md",sourceDirName:"cheatsheet/database",slug:"/cheatsheet/database/sql-optimize",permalink:"/docs/cheatsheet/database/sql-optimize",draft:!1,tags:[],version:"current",frontMatter:{title:"SQL Optimization"},sidebar:"cheatsheet",previous:{title:"MySQL CheatSheet",permalink:"/docs/cheatsheet/database/mysql"},next:{title:"Solidity CheatSheet",permalink:"/docs/cheatsheet/blockchain/solidity"}},s={},c=[{value:"1. Mastering JOINs for Enhanced Performance",id:"1-mastering-joins-for-enhanced-performance",level:3},{value:"2. Data Partitioning in PostgreSQL",id:"2-data-partitioning-in-postgresql",level:3},{value:"3. Leveraging Materialized Views",id:"3-leveraging-materialized-views",level:3},{value:"4. Optimistic vs. Pessimistic Locking",id:"4-optimistic-vs-pessimistic-locking",level:3},{value:"5. Exclusive vs. Shared Locks",id:"5-exclusive-vs-shared-locks",level:3},{value:"6. Multi-Version Concurrency Control (MVCC)",id:"6-multi-version-concurrency-control-mvcc",level:3},{value:"7. Understanding and Utilizing VACUUM",id:"7-understanding-and-utilizing-vacuum",level:3},{value:"8. Practical Vacuum Operations",id:"8-practical-vacuum-operations",level:3},{value:"9. Transaction Isolation Levels",id:"9-transaction-isolation-levels",level:3},{value:"10. PostgreSQL Best Practices",id:"10-postgresql-best-practices",level:3}],p={toc:c},u="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"1-mastering-joins-for-enhanced-performance"},"1. Mastering JOINs for Enhanced Performance"),(0,i.kt)("p",null,"Understanding different types of JOINs\u2014",(0,i.kt)("strong",{parentName:"p"},"INNER JOIN"),", ",(0,i.kt)("strong",{parentName:"p"},"LEFT JOIN"),", ",(0,i.kt)("strong",{parentName:"p"},"RIGHT JOIN"),", and ",(0,i.kt)("strong",{parentName:"p"},"FULL JOIN"),"\u2014is crucial for writing efficient queries. To optimize JOIN operations:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Indexing"),": Ensure that columns involved in JOIN conditions are properly indexed to speed up data retrieval."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Performance Analysis"),": Utilize tools like ",(0,i.kt)("inlineCode",{parentName:"li"},"EXPLAIN ANALYZE")," to examine query execution plans and identify bottlenecks."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"JOIN Selection"),": Choose the appropriate type of JOIN based on your specific use case to minimize unnecessary data processing.")),(0,i.kt)("h3",{id:"2-data-partitioning-in-postgresql"},"2. Data Partitioning in PostgreSQL"),(0,i.kt)("p",null,"Data partitioning involves dividing a large table into smaller, more manageable pieces. This can be achieved through:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Range Partitioning"),": Organizes data based on a range of values, which is ideal for time-series data."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"List and Hash Partitioning"),": Further techniques that allow for more flexible data distribution.")),(0,i.kt)("p",null,"Partitioning enhances query performance by reducing the amount of data scanned and simplifying data management."),(0,i.kt)("h3",{id:"3-leveraging-materialized-views"},"3. Leveraging Materialized Views"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Materialized Views")," store the result of a query physically, allowing for faster access to complex query results. Benefits include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Speed"),": Significantly accelerates the retrieval of complex queries."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Reduced Load"),": Minimizes the computational load on the database by avoiding repeated calculations.")),(0,i.kt)("p",null,"However, materialized views require manual refreshing (",(0,i.kt)("inlineCode",{parentName:"p"},"REFRESH MATERIALIZED VIEW"),") to stay updated with underlying data changes."),(0,i.kt)("h3",{id:"4-optimistic-vs-pessimistic-locking"},"4. Optimistic vs. Pessimistic Locking"),(0,i.kt)("p",null,"Concurrency control is vital for maintaining data integrity:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Optimistic Locking"),": Uses version columns to detect conflicts, suitable for environments with low contention."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Pessimistic Locking"),": Locks resources to prevent conflicts, ensuring safety in high-concurrency scenarios.")),(0,i.kt)("p",null,"Choosing the right locking mechanism depends on the specific requirements and expected transaction conflicts of your application."),(0,i.kt)("h3",{id:"5-exclusive-vs-shared-locks"},"5. Exclusive vs. Shared Locks"),(0,i.kt)("p",null,"PostgreSQL manages data access through different lock types:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Exclusive Locks"),": Prevent other transactions from reading or writing to the locked resource."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Shared Locks"),": Allow multiple transactions to read but not write to the resource.")),(0,i.kt)("p",null,"Monitoring locks using ",(0,i.kt)("inlineCode",{parentName:"p"},"pg_locks")," helps in diagnosing and resolving lock contention issues."),(0,i.kt)("h3",{id:"6-multi-version-concurrency-control-mvcc"},"6. Multi-Version Concurrency Control (MVCC)"),(0,i.kt)("p",null,"PostgreSQL\u2019s ",(0,i.kt)("strong",{parentName:"p"},"MVCC")," allows multiple transactions to occur simultaneously without interfering with each other by maintaining multiple versions of data rows. This approach effectively handles:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Dirty Reads"),": Prevents transactions from reading uncommitted changes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Non-repeatable Reads"),": Ensures consistent data views within a transaction.")),(0,i.kt)("p",null,"MVCC enhances concurrency while maintaining data consistency and integrity."),(0,i.kt)("h3",{id:"7-understanding-and-utilizing-vacuum"},"7. Understanding and Utilizing VACUUM"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"VACUUM")," command cleans up outdated data, freeing up space and maintaining database performance. There are two main types:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Regular VACUUM"),": Cleans up space without locking the table."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"VACUUM FULL"),": Reclaims more space but requires an exclusive lock on the table.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Auto-VACUUM")," is crucial for large systems to automate this maintenance task, ensuring continuous optimal performance."),(0,i.kt)("h3",{id:"8-practical-vacuum-operations"},"8. Practical Vacuum Operations"),(0,i.kt)("p",null,"Executing ",(0,i.kt)("inlineCode",{parentName:"p"},"VACUUM")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"REINDEX")," commands on large tables can significantly improve performance. Regular maintenance involves:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Running VACUUM"),": Cleans up dead tuples and updates statistics."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Reindexing"),": Rebuilds indexes to optimize query performance.")),(0,i.kt)("p",null,"Monitoring performance before and after these operations helps in assessing their impact."),(0,i.kt)("h3",{id:"9-transaction-isolation-levels"},"9. Transaction Isolation Levels"),(0,i.kt)("p",null,"PostgreSQL offers four isolation levels to balance performance and data integrity:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Read Uncommitted"),": Allows reading uncommitted changes (not commonly used in PostgreSQL)."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Read Committed"),": Ensures each statement sees only committed data."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Repeatable Read"),": Guarantees that all statements within a transaction see the same data snapshot."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Serializable"),": Provides the highest level of isolation, ensuring complete transaction isolation.")),(0,i.kt)("p",null,"Selecting the appropriate isolation level depends on the required balance between concurrency and consistency."),(0,i.kt)("h3",{id:"10-postgresql-best-practices"},"10. PostgreSQL Best Practices"),(0,i.kt)("p",null,"To optimize PostgreSQL performance, adhere to the following best practices:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Selective Column Retrieval"),": Avoid using ",(0,i.kt)("inlineCode",{parentName:"li"},"SELECT *"),"; instead, specify only the necessary columns."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Effective Indexing"),": Create indexes on frequently queried columns to speed up data access."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Performance Analysis"),": Regularly use ",(0,i.kt)("inlineCode",{parentName:"li"},"EXPLAIN ANALYZE")," to understand and optimize query execution plans."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Thoughtful Schema Design"),": Design tables and indexes carefully to support efficient querying and data integrity.")),(0,i.kt)("p",null,"Implementing these practices ensures your PostgreSQL databases run efficiently, handling queries swiftly and maintaining data integrity."))}m.isMDXComponent=!0}}]);