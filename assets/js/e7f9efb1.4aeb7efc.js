"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[571],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,k=u["".concat(l,".").concat(d)]||u[d]||m[d]||s;return n?a.createElement(k,o(o({ref:t},c),{},{components:n})):a.createElement(k,o({ref:t},c))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:r,o[1]=i;for(var p=2;p<s;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6732:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const s={title:"Design Pattern"},o=void 0,i={unversionedId:"cheatsheet/fundamental/design-pattern",id:"cheatsheet/fundamental/design-pattern",title:"Design Pattern",description:"CQRS",source:"@site/docs/cheatsheet/fundamental/design-pattern.md",sourceDirName:"cheatsheet/fundamental",slug:"/cheatsheet/fundamental/design-pattern",permalink:"/docs/cheatsheet/fundamental/design-pattern",draft:!1,tags:[],version:"current",frontMatter:{title:"Design Pattern"},sidebar:"cheatsheet",previous:{title:"Computer Science",permalink:"/docs/cheatsheet/fundamental/computer-science"},next:{title:"Programming Design Pattern",permalink:"/docs/cheatsheet/fundamental/programming-design-pattern"}},l={},p=[{value:"CQRS",id:"cqrs",level:2},{value:"Command Service",id:"command-service",level:3},{value:"Query Service",id:"query-service",level:3},{value:"Snapshot Service",id:"snapshot-service",level:3},{value:"Saga",id:"saga",level:2},{value:"Choreography Service",id:"choreography-service",level:3},{value:"Orchestration Service",id:"orchestration-service",level:3},{value:"Backends for Frontend",id:"backends-for-frontend",level:2},{value:"BFF Service",id:"bff-service",level:3},{value:"Transactional Outbox and Inbox",id:"transactional-outbox-and-inbox",level:2},{value:"Outbox Service",id:"outbox-service",level:3},{value:"Inbox Service",id:"inbox-service",level:3},{value:"Fan-out/Fan-in",id:"fan-outfan-in",level:2},{value:"Fan Service",id:"fan-service",level:3},{value:"Shared Database Anti-Pattern",id:"shared-database-anti-pattern",level:2}],c={toc:p},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"cqrs"},"CQRS"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"CQRS"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Core concepts"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Separation of database"),": Splits write (PostgreSQL) and read (snapshot) data stores."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Separation of concerns"),": Divides command (write) and query (read) logic."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Implementation"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Commands"),": Modify state in PostgreSQL."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Queries"),": Retrieve data from snapshot."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Event sourcing integration"),": Uses events to update snapshots.")))),(0,r.kt)("h3",{id:"command-service"},"Command Service"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/cqrs/command.service.ts (**Commands**)\nimport { Injectable } from "@nestjs/common";\nimport { Pool } from "pg";\nimport { SnapshotService } from "./snapshot.service";\n\n@Injectable()\nexport class CommandService {\n  private pool: Pool;\n\n  constructor(private snapshotService: SnapshotService) {\n    this.pool = new Pool({\n      user: "postgres",\n      host: "localhost",\n      database: "mydb",\n      password: "password",\n      port: 5432,\n    });\n  }\n\n  async createUser(id: number, name: string): Promise<void> {\n    const client = await this.pool.connect();\n    try {\n      await client.query("BEGIN");\n      await client.query("INSERT INTO users (id, name) VALUES ($1, $2)", [\n        id,\n        name,\n      ]);\n      await client.query("COMMIT");\n      this.snapshotService.updateSnapshot(id, name);\n      console.log(`User created in PostgreSQL: ${id}, ${name}`);\n    } catch (e) {\n      await client.query("ROLLBACK");\n      throw e;\n    } finally {\n      client.release();\n    }\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Command Service Details"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Handles write operations to a PostgreSQL database with event sourcing integration."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": Initializes a PostgreSQL connection pool, uses a transaction to insert a user into the ",(0,r.kt)("inlineCode",{parentName:"li"},"users")," table, updates the snapshot via ",(0,r.kt)("inlineCode",{parentName:"li"},"SnapshotService"),", and logs the action. Errors trigger a rollback for consistency."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"CQRS Details"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Separation of Database"),": Writes to PostgreSQL as the command store."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Commands"),": Modifies state with transactional integrity.")))),(0,r.kt)("h3",{id:"query-service"},"Query Service"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/cqrs/query.service.ts (**Queries**)\nimport { Injectable } from "@nestjs/common";\nimport { SnapshotService } from "./snapshot.service";\n\n@Injectable()\nexport class QueryService {\n  constructor(private snapshotService: SnapshotService) {}\n\n  async getUser(id: number): Promise<string> {\n    const data = this.snapshotService.getUser(id);\n    console.log(`Query from snapshot: ${data}`);\n    return data;\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Query Service Details"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Retrieves data from an in-memory snapshot store."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": Uses ",(0,r.kt)("inlineCode",{parentName:"li"},"SnapshotService")," to fetch user data by ID from the snapshot, logging and returning the result, keeping read operations separate from the write database."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"CQRS Details"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Separation of Concerns"),": Queries read from a snapshot, not the write store."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Event Sourcing Integration"),": Relies on snapshot updates from events.")))),(0,r.kt)("h3",{id:"snapshot-service"},"Snapshot Service"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/cqrs/snapshot.service.ts (**Event sourcing integration**)\nimport { Injectable } from "@nestjs/common";\n\n@Injectable()\nexport class SnapshotService {\n  private snapshot: Map<number, string>;\n\n  constructor() {\n    this.snapshot = new Map();\n  }\n\n  updateSnapshot(id: number, name: string): void {\n    this.snapshot.set(id, name);\n    console.log(`Snapshot updated: ${id}, ${name}`);\n  }\n\n  getUser(id: number): string {\n    return this.snapshot.get(id) || "User not found";\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Snapshot Service Details"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Manages an in-memory snapshot for read operations."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": Uses a ",(0,r.kt)("inlineCode",{parentName:"li"},"Map")," to store user data, ",(0,r.kt)("inlineCode",{parentName:"li"},"updateSnapshot")," adds or updates entries (simulating event-driven updates), and ",(0,r.kt)("inlineCode",{parentName:"li"},"getUser")," retrieves data, providing a fallback if not found."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"CQRS Details"),": Acts as the read model, updated via events from commands.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"saga"},"Saga"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Saga"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Distributed transactions"),": Manages transactions across services."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Choreography"),": Event-driven coordination using Kafka."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Orchestration"),": Centralized control with rollback."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Compensation transaction"),": Reverses actions on failure.")),(0,r.kt)("h3",{id:"choreography-service"},"Choreography Service"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/saga/choreography.service.ts (**Choreography**)\nimport { Injectable, OnModuleInit } from "@nestjs/common";\nimport { ClientKafka } from "@nestjs/microservices";\n\n@Injectable()\nexport class ChoreographyService implements OnModuleInit {\n  private kafkaClient: ClientKafka;\n\n  constructor() {\n    this.kafkaClient = new ClientKafka({\n      client: { brokers: ["localhost:9092"] },\n      consumer: { groupId: "saga-group" },\n    });\n  }\n\n  async onModuleInit() {\n    await this.kafkaClient.connect();\n  }\n\n  async startOrder(orderID: number): Promise<void> {\n    await this.kafkaClient\n      .emit("order-events", { key: String(orderID), value: "OrderStarted" })\n      .toPromise();\n    console.log(`Order started, event published: ${orderID}`);\n    // Simulate failure and compensation\n    await this.kafkaClient\n      .emit("order-events", { key: String(orderID), value: "OrderCancelled" })\n      .toPromise();\n    console.log(`Compensation: Order cancelled: ${orderID}`);\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Choreography Service Details"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Implements event-driven coordination with Kafka."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": Initializes a Kafka client, connects on module init, and ",(0,r.kt)("inlineCode",{parentName:"li"},"startOrder"),' publishes an "OrderStarted" event, followed by a simulated failure with an "OrderCancelled" compensating event, logged for visibility.'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Saga Details"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Choreography"),": Kafka events drive coordination across services."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Compensation Transaction"),': "OrderCancelled" reverses the initial action.')))),(0,r.kt)("h3",{id:"orchestration-service"},"Orchestration Service"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/saga/orchestration.service.ts (**Orchestration**)\nimport { Injectable } from "@nestjs/common";\n\n@Injectable()\nexport class OrchestrationService {\n  private steps = [\n    {\n      action: "Create order",\n      rollback: (id: number) => console.log(`Rollback: Cancel order ${id}`),\n    },\n    {\n      action: "Process payment",\n      rollback: (id: number) => console.log(`Rollback: Refund payment ${id}`),\n    },\n  ];\n\n  async processOrder(orderID: number): Promise<void> {\n    for (let i = 0; i < this.steps.length; i++) {\n      const step = this.steps[i];\n      console.log(`Executing: ${step.action}`);\n      if (step.action === "Process payment") {\n        for (let j = i; j >= 0; j--) {\n          this.steps[j].rollback(orderID);\n        }\n        throw new Error(`Payment failed for order ${orderID}`);\n      }\n    }\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Orchestration Service Details"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Manages a centralized transaction with rollback capabilities."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": Defines steps with actions and rollback functions, ",(0,r.kt)("inlineCode",{parentName:"li"},"processOrder"),' executes them sequentially, simulates a failure at "Process payment," and triggers rollbacks in reverse order, throwing an error to indicate failure.'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Saga Details"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Orchestration"),": Central control over transaction steps."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Compensation Transaction"),": Rollbacks reverse actions on failure.")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"backends-for-frontend"},"Backends for Frontend"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Backends for frontend"),": Tailors backend APIs for frontends via GraphQL."),(0,r.kt)("h3",{id:"bff-service"},"BFF Service"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/bff/bff.service.ts (**Backends for frontend**)\nimport { Injectable } from "@nestjs/common";\nimport {\n  GraphQLObjectType,\n  GraphQLSchema,\n  GraphQLString,\n  graphql,\n} from "graphql";\n\n@Injectable()\nexport class BFFService {\n  async queryGraphQL(): Promise<string> {\n    const schema = new GraphQLSchema({\n      query: new GraphQLObjectType({\n        name: "Query",\n        fields: {\n          user: {\n            type: GraphQLString,\n            resolve: () => "John Doe",\n          },\n        },\n      }),\n    });\n    const result = await graphql({ schema, source: "{ user }" });\n    return `GraphQL result: ${result.data.user}`;\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"BFF Service Details"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Provides a GraphQL API tailored for frontends."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": Defines a GraphQL schema with a ",(0,r.kt)("inlineCode",{parentName:"li"},"user"),' field resolving to "John Doe," executes a query, and returns the result, offering a flexible API for frontend consumption.'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"BFF Details"),": GraphQL enables tailored responses for frontend needs (e.g., mobile, web).")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"transactional-outbox-and-inbox"},"Transactional Outbox and Inbox"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Transactional outbox and inbox"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Outbox pattern"),": Ensures reliable event publishing with DB transactions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Inbox pattern"),": Guarantees idempotent event consumption.")),(0,r.kt)("h3",{id:"outbox-service"},"Outbox Service"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/outbox/outbox.service.ts (**Outbox pattern**)\nimport { Injectable } from "@nestjs/common";\nimport { Pool } from "pg";\n\n@Injectable()\nexport class OutboxService {\n  private pool: Pool;\n\n  constructor() {\n    this.pool = new Pool({\n      user: "postgres",\n      host: "localhost",\n      database: "mydb",\n      password: "password",\n      port: 5432,\n    });\n  }\n\n  async publishEvent(eventType: string, payload: string): Promise<void> {\n    const client = await this.pool.connect();\n    try {\n      await client.query("BEGIN");\n      await client.query(\n        "INSERT INTO outbox (event_type, payload) VALUES ($1, $2)",\n        [eventType, payload]\n      );\n      await client.query("COMMIT");\n      console.log(`Event published to outbox: ${eventType}, ${payload}`);\n    } catch (e) {\n      await client.query("ROLLBACK");\n      throw e;\n    } finally {\n      client.release();\n    }\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Outbox Service Details"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Ensures reliable event publishing within a database transaction."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": Initializes a PostgreSQL pool, ",(0,r.kt)("inlineCode",{parentName:"li"},"publishEvent")," starts a transaction, inserts an event into an ",(0,r.kt)("inlineCode",{parentName:"li"},"outbox")," table, and commits it, ensuring atomicity with any related write operation, logging the action."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Outbox Details"),": Ties event publishing to DB transactions for reliability.")),(0,r.kt)("h3",{id:"inbox-service"},"Inbox Service"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/inbox/inbox.service.ts (**Inbox pattern**)\nimport { Injectable } from "@nestjs/common";\n\n@Injectable()\nexport class InboxService {\n  private processedEvents: Set<string>;\n\n  constructor() {\n    this.processedEvents = new Set();\n  }\n\n  processEvent(eventID: string, eventType: string): void {\n    if (this.processedEvents.has(eventID)) {\n      console.log(`Event already processed (idempotent): ${eventID}`);\n      return;\n    }\n    console.log(`Processing event: ${eventID}, ${eventType}`);\n    this.processedEvents.add(eventID);\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Inbox Service Details"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Ensures idempotent event consumption."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": Uses a ",(0,r.kt)("inlineCode",{parentName:"li"},"Set")," to track processed event IDs, ",(0,r.kt)("inlineCode",{parentName:"li"},"processEvent")," checks if an event has been processed, skips it if so (idempotency), otherwise processes and logs it, adding the ID to the set."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Inbox Details"),": Prevents duplicate event processing (e.g., from retries).")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"fan-outfan-in"},"Fan-out/Fan-in"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Fan-out/fan-in"),": Distributes tasks (fan-out) and aggregates results (fan-in)."),(0,r.kt)("h3",{id:"fan-service"},"Fan Service"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/fan/fan.service.ts (**Fan-out/fan-in**)\nimport { Injectable } from "@nestjs/common";\n\n@Injectable()\nexport class FanService {\n  async processTasks(tasks: number[]): Promise<number> {\n    const promises = tasks.map(async (task) => {\n      console.log(`Processing task: ${task}`);\n      return task * 2;\n    });\n    const results = await Promise.all(promises);\n    const sum = results.reduce((acc, val) => acc + val, 0);\n    console.log(`Fan-out/fan-in result: ${sum}`);\n    return sum;\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Fan Service Details"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Implements fan-out/fan-in for task distribution and aggregation."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"processTasks")," maps tasks to async operations (fan-out) that double each value, uses ",(0,r.kt)("inlineCode",{parentName:"li"},"Promise.all")," to await all results, and reduces them to a sum (fan-in), logging the final result."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Fan-out/Fan-in Details"),": Distributes work across concurrent tasks and aggregates results efficiently.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"shared-database-anti-pattern"},"Shared Database Anti-Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Shared database anti-pattern"),": Avoids single DB across services due to coupling."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Highlights the anti-pattern conceptually."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Shared Database Anti-Pattern Details"),": Using a single DB across microservices leads to tight coupling, schema conflicts, and scaling challenges.")))}m.isMDXComponent=!0}}]);