"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2310],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),p=s(n),h=a,d=p["".concat(l,".").concat(h)]||p[h]||m[h]||o;return n?r.createElement(d,i(i({ref:t},u),{},{components:n})):r.createElement(d,i({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[p]="string"==typeof e?e:a,i[1]=c;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5369:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>c,toc:()=>s});var r=n(7462),a=(n(7294),n(3905));const o={title:"Event Loop"},i=void 0,c={unversionedId:"programming/nodejs/event-loop",id:"programming/nodejs/event-loop",title:"Event Loop",description:"Fundamental",source:"@site/docs/programming/nodejs/event-loop.md",sourceDirName:"programming/nodejs",slug:"/programming/nodejs/event-loop",permalink:"/docs/programming/nodejs/event-loop",draft:!1,tags:[],version:"current",frontMatter:{title:"Event Loop"},sidebar:"programming",previous:{title:"Node.js Fundamental",permalink:"/docs/programming/nodejs/fundamental"},next:{title:"Process and Thread",permalink:"/docs/programming/nodejs/process-thread"}},l={},s=[{value:"Fundamental",id:"fundamental",level:2}],u={toc:s},p="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"fundamental"},"Fundamental"),(0,a.kt)("p",null,"In Node.js, the event loop is a fundamental concept that plays a crucial role in managing asynchronous operations. The event loop is responsible for handling non-blocking I/O operations, timers, and callbacks in an efficient manner, allowing Node.js to handle a large number of concurrent connections without blocking the execution of other code."),(0,a.kt)("p",null,"Here's a high-level overview of how the event loop works in Node.js:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Event Loop"),": The event loop is a continuous process that keeps running in the background of a Node.js application. It constantly checks whether there are any pending events or callbacks in the queue."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Callback Queue"),": When asynchronous operations are performed, such as reading from a file, making a network request, or setting a timer, the associated callback functions are placed in a callback queue. These callbacks are executed once the main thread is free, and the event loop checks the callback queue."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Macro Queue (Task Queue)"),": This is where the callback functions related to I/O operations, timers, and some other asynchronous tasks are queued. The event loop checks the macro queue after it has finished executing the current task in the callback queue. Tasks in the macro queue have a slightly higher priority than those in the micro queue."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Micro Queue (Microtask Queue)"),": The micro queue is a queue that contains microtasks. Microtasks are usually callback functions that are meant to be executed immediately after the current operation in the event loop is completed. Microtasks have a higher priority than the tasks in the macro queue. Promises and certain API functions (e.g., process.nextTick) are typically executed as microtasks."),(0,a.kt)("p",null,"Here's a simplified order of execution in the event loop:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The event loop starts."),(0,a.kt)("li",{parentName:"ul"},"It checks the callback queue for pending callbacks."),(0,a.kt)("li",{parentName:"ul"},"If there are callbacks in the callback queue, they are executed one by one."),(0,a.kt)("li",{parentName:"ul"},"After each callback is executed, the event loop checks the micro queue for microtasks."),(0,a.kt)("li",{parentName:"ul"},"If there are microtasks in the micro queue, they are executed immediately, without returning to the callback queue."),(0,a.kt)("li",{parentName:"ul"},"The event loop repeats this process, checking the callback queue, then the micro queue, until there are no more pending tasks.")),(0,a.kt)("p",null,"This event-driven, non-blocking architecture is what allows Node.js to efficiently handle a large number of concurrent connections and perform asynchronous operations while maintaining high performance. Understanding how the event loop works is essential for writing efficient and scalable Node.js applications."),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/quankori/quankori.github.io/master/src/images/programming/9.gif",alt:"Image"})))}m.isMDXComponent=!0}}]);