"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[641],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},m="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,d=m["".concat(s,".").concat(u)]||m[u]||g[u]||a;return n?i.createElement(d,o(o({ref:t},c),{},{components:n})):i.createElement(d,o({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<a;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7054:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>g,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var i=n(7462),r=(n(7294),n(3905));const a={title:"Design Principle"},o=void 0,l={unversionedId:"blog/fundamental/design-principle",id:"blog/fundamental/design-principle",title:"Design Principle",description:"Monolithic First Strategy",source:"@site/docs/blog/fundamental/design-principle.md",sourceDirName:"blog/fundamental",slug:"/blog/fundamental/design-principle",permalink:"/blog/fundamental/design-principle",draft:!1,tags:[],version:"current",frontMatter:{title:"Design Principle"}},s={},p=[{value:"Monolithic First Strategy",id:"monolithic-first-strategy",level:2},{value:"Monolithic First Explanation",id:"monolithic-first-explanation",level:3},{value:"Polyglot Persistence",id:"polyglot-persistence",level:2},{value:"Polyglot Persistence Service",id:"polyglot-persistence-service",level:3},{value:"Core Development Principles",id:"core-development-principles",level:2},{value:"Inversion of Control (IoC)",id:"inversion-of-control-ioc",level:2},{value:"IoC Service",id:"ioc-service",level:3},{value:"CAP Theorem",id:"cap-theorem",level:2},{value:"CAP Theorem Explanation",id:"cap-theorem-explanation",level:3},{value:"Scalability Principles",id:"scalability-principles",level:2}],c={toc:p},m="wrapper";function g(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"monolithic-first-strategy"},"Monolithic First Strategy"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Monolithic first strategy"),": Starts with a single, unified app before evolving to distributed systems."),(0,r.kt)("h3",{id:"monolithic-first-explanation"},"Monolithic First Explanation"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Begins development with a monolithic architecture to simplify initial design and deployment, then refactors into microservices as complexity grows."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": A monolithic app consolidates all functionality (e.g., UI, business logic, data access) into one codebase and deployment unit. This approach speeds up early development and testing, allowing a team to establish a working system before addressing scalability needs with distributed systems."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Details"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"When to Use"),": Early-stage projects with unclear boundaries or small teams."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Evolution"),": Split into microservices when scaling or team size increases (e.g., using domain-driven design to identify service boundaries)."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"No Code Needed"),": Conceptual strategy, implemented via project structure rather than specific code.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"polyglot-persistence"},"Polyglot Persistence"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Polyglot persistence"),": Uses multiple database types for different needs (e.g., SQL, NoSQL)."),(0,r.kt)("h3",{id:"polyglot-persistence-service"},"Polyglot Persistence Service"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/polyglot/polyglot.service.ts (**Polyglot persistence**)\nimport { Injectable } from "@nestjs/common";\nimport { Pool } from "pg";\nimport { Redis } from "ioredis";\n\n@Injectable()\nexport class PolyglotService {\n  private pgPool: Pool;\n  private redis: Redis;\n\n  constructor() {\n    this.pgPool = new Pool({\n      user: "postgres",\n      host: "localhost",\n      database: "mydb",\n      password: "password",\n      port: 5432,\n    });\n    this.redis = new Redis({ host: "localhost", port: 6379 });\n  }\n\n  async saveToSQL(id: number, name: string): Promise<void> {\n    await this.pgPool.query("INSERT INTO users (id, name) VALUES ($1, $2)", [\n      id,\n      name,\n    ]);\n    console.log(`Saved to PostgreSQL: ${id}, ${name}`);\n  }\n\n  async saveToNoSQL(key: string, value: string): Promise<void> {\n    await this.redis.set(key, value);\n    console.log(`Saved to Redis: ${key}, ${value}`);\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Polyglot Persistence Service Details"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Demonstrates using PostgreSQL (SQL) and Redis (NoSQL) for different persistence needs."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": Initializes connections to PostgreSQL (for structured data) and Redis (for key-value data), with ",(0,r.kt)("inlineCode",{parentName:"li"},"saveToSQL")," storing user data in a relational table and ",(0,r.kt)("inlineCode",{parentName:"li"},"saveToNoSQL")," caching data in Redis, showing how different DBs serve distinct purposes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Polyglot Persistence Details"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Multiple DB Types"),": SQL for relational data (e.g., user records), NoSQL for fast access (e.g., caching)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Use Case"),": PostgreSQL for persistent storage, Redis for session data or caching.")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"core-development-principles"},"Core Development Principles"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Core development principles"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"SOLID"),": Five principles (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) for clean code."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"DRY"),": Avoids code duplication (Don\u2019t Repeat Yourself)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"KISS"),": Keeps designs simple (Keep It Simple, Stupid)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"YAGNI"),": Avoids unnecessary features (You Aren\u2019t Gonna Need It)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"GRASP"),": Assigns responsibilities effectively (General Responsibility Assignment Software Patterns).")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"inversion-of-control-ioc"},"Inversion of Control (IoC)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Inversion of control (IoC)"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Dependency injection"),": Passes dependencies to objects rather than creating them internally."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"IoC containers"),": Manages dependency injection automatically (e.g., NestJS DI)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Service locator"),": Retrieves dependencies from a central registry.")),(0,r.kt)("h3",{id:"ioc-service"},"IoC Service"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/ioc/ioc.service.ts (**Dependency injection, IoC containers**)\nimport { Injectable } from "@nestjs/common";\n\ninterface Logger {\n  log(message: string): void;\n}\n\n@Injectable()\nexport class ConsoleLogger implements Logger {\n  log(message: string): void {\n    console.log(`Console: ${message}`);\n  }\n}\n\n@Injectable()\nexport class IoCService {\n  constructor(private logger: Logger) {} // Dependency injection via IoC container\n\n  performTask(): void {\n    this.logger.log("Task performed");\n  }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"IoC Service Details"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Demonstrates dependency injection and IoC container usage in NestJS."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"ConsoleLogger")," implements a ",(0,r.kt)("inlineCode",{parentName:"li"},"Logger")," interface, and ",(0,r.kt)("inlineCode",{parentName:"li"},"IoCService")," receives it via constructor injection managed by NestJS\u2019s IoC container, allowing ",(0,r.kt)("inlineCode",{parentName:"li"},"performTask")," to use the injected logger without creating it internally."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"IoC Details"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Dependency Injection"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"logger")," injected rather than instantiated."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"IoC Containers"),": NestJS automatically resolves and injects dependencies."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Service Locator"),": Not shown (less common in NestJS; typically a manual registry pattern).")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"cap-theorem"},"CAP Theorem"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"CAP theorem"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Consistency"),": Ensures all nodes see the same data at the same time."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Availability"),": Guarantees a response even during failures."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Partition tolerance"),": Handles network partitions gracefully."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Trade-offs"),": Balances CAP properties (e.g., CA, CP, AP systems).")),(0,r.kt)("h3",{id:"cap-theorem-explanation"},"CAP Theorem Explanation"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Purpose"),": Defines constraints in distributed systems."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explanation"),": CAP theorem states a system can prioritize only two of three properties: Consistency (all nodes have the same data), Availability (always responds), and Partition Tolerance (works despite network splits). For example, a CA system (e.g., RDBMS) sacrifices partition tolerance, while an AP system (e.g., Cassandra) sacrifices consistency for availability during partitions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Details"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Consistency"),": Strong in single-node systems (e.g., PostgreSQL)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Availability"),": Prioritized in NoSQL like Redis during partitions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Partition Tolerance"),": Essential for distributed systems (e.g., Kafka)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Trade-offs"),": CP (consistency + partition tolerance) or AP (availability + partition tolerance) common in microservices.")))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"scalability-principles"},"Scalability Principles"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Scalability principles"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Horizontal vs vertical scaling"),": Adds servers (horizontal) or upgrades hardware (vertical)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Load balancing"),": Distributes traffic across servers (e.g., Nginx)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Caching strategies"),": Improves performance with in-memory storage (e.g., Redis).")))}g.isMDXComponent=!0}}]);