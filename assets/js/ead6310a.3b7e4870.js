"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2005],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>m});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=l(r),h=a,m=u["".concat(c,".").concat(h)]||u[h]||d[h]||o;return r?n.createElement(m,s(s({ref:t},p),{},{components:r})):n.createElement(m,s({ref:t},p))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,s=new Array(o);s[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[u]="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=r[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},4347:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var n=r(7462),a=(r(7294),r(3905));const o={title:"Process and Thread"},s=void 0,i={unversionedId:"programming/concept/processandthread",id:"programming/concept/processandthread",title:"Process and Thread",description:"Process",source:"@site/docs/programming/concept/processandthread.md",sourceDirName:"programming/concept",slug:"/programming/concept/processandthread",permalink:"/docs/programming/concept/processandthread",draft:!1,tags:[],version:"current",frontMatter:{title:"Process and Thread"},sidebar:"programming",previous:{title:"Big O Notation",permalink:"/docs/programming/concept/bigo"},next:{title:"Object-oriented programming",permalink:"/docs/programming/concept/oop"}},c={},l=[{value:"Process",id:"process",level:2},{value:"Thread",id:"thread",level:2},{value:"When a request is sent to a server",id:"when-a-request-is-sent-to-a-server",level:2},{value:"Multi-Process Architecture:",id:"multi-process-architecture",level:3},{value:"Multi-Thread Architecture:",id:"multi-thread-architecture",level:3}],p={toc:l},u="wrapper";function d(e){let{components:t,...r}=e;return(0,a.kt)(u,(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"process"},"Process"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A process is an independent unit of a running program with its own memory space."),(0,a.kt)("li",{parentName:"ul"},"Each process has one or more threads."),(0,a.kt)("li",{parentName:"ul"},"Processes are often less interconnected. Communication between processes typically requires IPC (Inter-process communication) methods such as pipes, sockets, etc."),(0,a.kt)("li",{parentName:"ul"},"Initializing a new process is generally more resource-intensive and time-consuming than initializing a new thread.")),(0,a.kt)("h2",{id:"thread"},"Thread"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A thread, also called a lightweight process, is the smallest unit of execution within a process."),(0,a.kt)("li",{parentName:"ul"},"All threads within the same process share the memory space of that process. This means threads can access and modify shared variables and data structures."),(0,a.kt)("li",{parentName:"ul"},"Each thread has its own stack, but they share the heap (dynamic memory) and global data.")),(0,a.kt)("h2",{id:"when-a-request-is-sent-to-a-server"},"When a request is sent to a server"),(0,a.kt)("p",null,"Depending on the server's configuration and architecture, a request can be handled by a specific process or thread. Below is a simple example of how a server operates based on multi-process and multi-thread architectures:"),(0,a.kt)("h3",{id:"multi-process-architecture"},"Multi-Process Architecture:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"For each new request, the server may spawn a new process to handle that request. The Apache HTTP Server, when running in prefork mode (a popular mode), operates this way.")),(0,a.kt)("h3",{id:"multi-thread-architecture"},"Multi-Thread Architecture:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"For a new request, rather than spawning a new process, the server just spawns a new thread (or uses an existing one from a thread pool) within the same process to handle the request. Microsoft's IIS operates this way.")),(0,a.kt)("p",null,"Modern servers like Node.js utilize an event-driven model and event loop to handle multiple requests without the need for multiple threads or processes."),(0,a.kt)("p",null,"Depending on the architecture and technology in use, request handling will rely on one or several processes and threads. Each architecture has its pros and cons, and the choice between them often depends on the specific requirements and context of the system."))}d.isMDXComponent=!0}}]);