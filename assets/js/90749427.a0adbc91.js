"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8218],{3905:(e,r,n)=>{n.d(r,{Zo:()=>p,kt:()=>h});var t=n(7294);function s(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function o(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function a(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?o(Object(n),!0).forEach((function(r){s(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function i(e,r){if(null==e)return{};var n,t,s=function(e,r){if(null==e)return{};var n,t,s={},o=Object.keys(e);for(t=0;t<o.length;t++)n=o[t],r.indexOf(n)>=0||(s[n]=e[n]);return s}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)n=o[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=t.createContext({}),l=function(e){var r=t.useContext(c),n=r;return e&&(n="function"==typeof e?e(r):a(a({},r),e)),n},p=function(e){var r=l(e.components);return t.createElement(c.Provider,{value:r},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},u=t.forwardRef((function(e,r){var n=e.components,s=e.mdxType,o=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=l(n),u=s,h=d["".concat(c,".").concat(u)]||d[u]||m[u]||o;return n?t.createElement(h,a(a({ref:r},p),{},{components:n})):t.createElement(h,a({ref:r},p))}));function h(e,r){var n=arguments,s=r&&r.mdxType;if("string"==typeof e||s){var o=n.length,a=new Array(o);a[0]=u;var i={};for(var c in r)hasOwnProperty.call(r,c)&&(i[c]=r[c]);i.originalType=e,i[d]="string"==typeof e?e:s,a[1]=i;for(var l=2;l<o;l++)a[l]=n[l];return t.createElement.apply(null,a)}return t.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1976:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var t=n(7462),s=(n(7294),n(3905));const o={title:"Process and Thread"},a=void 0,i={unversionedId:"programming/nodejs/process-thread",id:"programming/nodejs/process-thread",title:"Process and Thread",description:"Concept",source:"@site/docs/programming/nodejs/process-thread.md",sourceDirName:"programming/nodejs",slug:"/programming/nodejs/process-thread",permalink:"/docs/programming/nodejs/process-thread",draft:!1,tags:[],version:"current",frontMatter:{title:"Process and Thread"},sidebar:"programming",previous:{title:"Node.js Concept",permalink:"/docs/programming/nodejs/concept"},next:{title:"Callbacks in Node.js",permalink:"/docs/programming/nodejs/callback"}},c={},l=[{value:"Concept",id:"concept",level:2},{value:"Child Processes:",id:"child-processes",level:2},{value:"Worker Threads:",id:"worker-threads",level:2},{value:"Cluster mode",id:"cluster-mode",level:2}],p={toc:l},d="wrapper";function m(e){let{components:r,...n}=e;return(0,s.kt)(d,(0,t.Z)({},p,n,{components:r,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"concept"},"Concept"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Process"),": It is an independent unit that contains a program being executed and its resources. Each process has its own address space, and one process cannot directly access the address space of another process (unless using IPC mechanisms)."),(0,s.kt)("p",null,"IPC stands for Inter-Process Communication. It is a set of methods for different processes to communicate with each other. IPC is used in both single and multi-system environments, allowing processes to share data, signals, or messages in a coordinated and safe manner."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/quankori/quankori.github.io/master/src/images/programming/2.png",alt:"Image"})),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Thread"),": It is the smallest unit of code being executed. A process can contain multiple threads. All threads within the same process share the address space of that process, making data sharing among threads easier. However, this also brings synchronization challenges."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/quankori/quankori.github.io/master/src/images/programming/6.png",alt:"Image"})),(0,s.kt)("h2",{id:"child-processes"},"Child Processes:"),(0,s.kt)("p",null,"In Node.js, when you want to execute a system command, you can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"child_process")," module. This module allows you to run system commands, manage child processes, and communicate with them, when you wish to execute a system command or need to isolate logic in an entirely separate process."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const { exec } = require("child_process");\n\nexec("ls -la", (error, stdout, stderr) => {\n  if (error) {\n    console.error(`exec error: ${error}`);\n    return;\n  }\n  console.log(`Output: ${stdout}`);\n  console.error(`Errors: ${stderr}`);\n});\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const { fork } = require("child_process");\n\nconst child = fork("./child-script.js");\n\nchild.on("message", (msg) => {\n  console.log("Message from child:", msg);\n});\n\nchild.send({ hello: "world" });\n')),(0,s.kt)("p",null,"In file ",(0,s.kt)("inlineCode",{parentName:"p"},"child-script.js")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'process.on("message", (msg) => {\n  console.log("Message from parent:", msg);\n  process.send({ msg: "Hello from child!" });\n});\n')),(0,s.kt)("p",null,"When you create a child process, you are launching an entirely new system process. In a Unix environment, this is often done using the fork() command."),(0,s.kt)("p",null,"fork(): It is a system command used to create a copy of the current process. This command returns twice: once for the original (parent) process and once for the child process. In Node.js, fork() helps create a new Node.js child process and establishes an IPC communication channel between them."),(0,s.kt)("p",null,"spawn() and exec(): Both of these methods create a child process, but they differ in terms of communication and output management. spawn() returns a stream and is suitable for handling applications with large amounts of data. exec() returns the entire output as a string when the child process ends."),(0,s.kt)("p",null,"IPC (Inter-Process Communication) is a mechanism that allows two (or more) processes to communicate and share data with each other."),(0,s.kt)("h2",{id:"worker-threads"},"Worker Threads:"),(0,s.kt)("p",null,"Starting from Node.js 10.5.0, a new module called ",(0,s.kt)("inlineCode",{parentName:"p"},"worker_threads")," was introduced. It provides a means to create threads, making parallel computation easier in the Node.js environment, when you need to boost computational performance by leveraging unused CPU cores and you want to keep all logic within the same process."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const { Worker, isMainThread, parentPort } = require("worker_threads");\n\nif (isMainThread) {\n  // This is the main thread\n\n  const worker = new Worker(__filename); // Start a new worker with this file\n\n  worker.on("message", (msg) => {\n    console.log("Message from worker:", msg);\n  });\n\n  worker.postMessage("Hello Worker!");\n} else {\n  // This is the worker thread\n\n  parentPort.on("message", (msg) => {\n    console.log("Message from main thread:", msg);\n    parentPort.postMessage("Hello Main Thread!");\n  });\n}\n')),(0,s.kt)("p",null,"Node.js runs on a single thread by default, using the event loop to handle asynchronous operations. However, some tasks, especially computational tasks, can block the event loop, reducing performance."),(0,s.kt)("p",null,"That's where worker_threads come in:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"When you create a Worker, a new thread is spawned, running parallel to the main thread."),(0,s.kt)("li",{parentName:"ul"},"Each worker has its own event loop and context, meaning they operate independently and do not share state."),(0,s.kt)("li",{parentName:"ul"},"Workers can communicate with the main thread and with each other using a message-passing mechanism."),(0,s.kt)("li",{parentName:"ul"},"Objects like ArrayBuffer can be shared between threads, but sharing data among threads requires caution to avoid issues like race conditions.")),(0,s.kt)("p",null,'In general, "child processes" are suitable when you need complete separation or when running tasks independent of Node.js. Meanwhile, "worker threads" are beneficial when you want to utilize all the cores on a CPU without having to launch multiple instances of Node.js.'),(0,s.kt)("h2",{id:"cluster-mode"},"Cluster mode"),(0,s.kt)("p",null,"Cluster mode is a feature in Node.js that allows you to create multiple child processes to run the same Node.js application on a computer or network. Each child process can run on a separate CPU or core, so it can take advantage of the power of CPUs or cores in the system."),(0,s.kt)("p",null,"In Cluster mode, the master process is responsible for creating and managing the worker processes. The master process shares TCP and UDP connections with the worker processes, allowing them to share network connections and process requests concurrently. When a request is received, the master process distributes the request to one of the available worker processes."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'const cluster = require("cluster");\nconst http = require("http");\nconst numCPUs = require("os").cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n\n  // Fork workers.\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on("exit", (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n  });\n} else {\n  // Workers can share any TCP connection\n  // In this example, it\'s an HTTP server\n  http\n    .createServer((req, res) => {\n      res.writeHead(200);\n      res.end("Hello from Node.js!");\n    })\n    .listen(8000);\n\n  console.log(`Worker ${process.pid} started`);\n}\n')),(0,s.kt)("p",null,"Explanation:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"We first check if the current process is the master process using cluster.isMaster. The master process is responsible for forking child processes (workers)."),(0,s.kt)("li",{parentName:"ol"},"If it's the master process, we fork as many workers as there are CPU cores using cluster.fork()."),(0,s.kt)("li",{parentName:"ol"},"We set up an event listener on the master process to listen for the exit event. This event is emitted when a worker process dies."),(0,s.kt)("li",{parentName:"ol"},"If it's not the master (meaning it's a worker process), we set up an HTTP server that listens on port 8000 and responds with \"Hello from Node.js!\".")))}m.isMDXComponent=!0}}]);