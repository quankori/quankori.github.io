"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1210],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>y});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function m(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),i=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},s=function(e){var n=i(e.components);return r.createElement(c.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,s=m(e,["components","mdxType","originalType","parentName"]),p=i(t),g=a,y=p["".concat(c,".").concat(g)]||p[g]||u[g]||o;return t?r.createElement(y,l(l({ref:n},s),{},{components:t})):r.createElement(y,l({ref:n},s))}));function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,l=new Array(o);l[0]=g;var m={};for(var c in n)hasOwnProperty.call(n,c)&&(m[c]=n[c]);m.originalType=e,m[p]="string"==typeof e?e:a,l[1]=m;for(var i=2;i<o;i++)l[i]=t[i];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},2005:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>m,toc:()=>i});var r=t(7462),a=(t(7294),t(3905));const o={title:"Memory Managements"},l=void 0,m={unversionedId:"programming/go/memory-management",id:"programming/go/memory-management",title:"Memory Managements",description:"In Go (Golang), memory management is automatically handled by Go's garbage collector. The Go garbage collector helps clean up memory whenever an object is no longer referenced and in use.",source:"@site/docs/programming/go/memory-management.md",sourceDirName:"programming/go",slug:"/programming/go/memory-management",permalink:"/docs/programming/go/memory-management",draft:!1,tags:[],version:"current",frontMatter:{title:"Memory Managements"},sidebar:"programming",previous:{title:"Closures & Anounymous Function",permalink:"/docs/programming/go/closures-anonymous"},next:{title:"Panic & Recover",permalink:"/docs/programming/go/panic-recover"}},c={},i=[{value:"Example",id:"example",level:2}],s={toc:i},p="wrapper";function u(e){let{components:n,...t}=e;return(0,a.kt)(p,(0,r.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In Go (Golang), memory management is automatically handled by Go's garbage collector. The Go garbage collector helps clean up memory whenever an object is no longer referenced and in use."),(0,a.kt)("p",null,"Here are some fundamental points related to memory management in Go:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Garbage Collector (GC)"),": Go uses a garbage collector to track and reclaim unused objects. The GC automatically scans and frees memory that holds unreferenced objects."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Automatic Memory Management"),": In Go, you don't need to manually allocate and deallocate memory as in some other languages. Go automatically allocates and frees memory based on object references."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Heap and Stack Memory"),": Go uses two primary memory areas, heap and stack. Local variables and function parameters are stored on the stack. Dynamically allocated objects are stored on the heap."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Memory Allocation Control"),": In Go, you don't need to worry about manual memory deallocation, but you should avoid creating unwanted reference cycles. This can happen when one object references another, creating a reference loop."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Sync.Pool"),": Sync.Pool is a mechanism provided by Go to manage temporary objects such as buffers or object pools for reuse. This helps reduce memory pressure and improves performance."),(0,a.kt)("p",null,"In summary, Go helps you avoid complex memory management issues by using a garbage collector and automatic rules. This simplifies application development and minimizes risks associated with memory management errors."),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\nfunc main() {\n    // Create a new slice with automatic memory management\n    slice := make([]int, 0, 10)\n\n    // Add elements to the slice\n    for i := 1; i <= 10; i++ {\n        slice = append(slice, i)\n    }\n\n    // No need to manually deallocate memory when done with the slice\n    // The garbage collector will take care of it\n    fmt.Println("Slice:", slice)\n}\n')),(0,a.kt)("p",null,"In this example, we create a slice, add elements to it, and there's no need to manually deallocate memory when we're done with the slice. Go's garbage collector will automatically reclaim the memory."))}u.isMDXComponent=!0}}]);