"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>p});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),s=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=s(e.components);return r.createElement(l.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),m=s(t),f=a,p=m["".concat(l,".").concat(f)]||m[f]||d[f]||i;return t?r.createElement(p,o(o({ref:n},u),{},{components:t})):r.createElement(p,o({ref:n},u))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=f;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c[m]="string"==typeof e?e:a,o[1]=c;for(var s=2;s<i;s++)o[s]=t[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},8859:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>s});var r=t(7462),a=(t(7294),t(3905));const i={title:"Fundamental CheatSheet"},o=void 0,c={unversionedId:"cheatsheet/go/core",id:"cheatsheet/go/core",title:"Fundamental CheatSheet",description:"Concurrency",source:"@site/docs/cheatsheet/go/core.md",sourceDirName:"cheatsheet/go",slug:"/cheatsheet/go/core",permalink:"/docs/cheatsheet/go/core",draft:!1,tags:[],version:"current",frontMatter:{title:"Fundamental CheatSheet"},sidebar:"cheatsheet",previous:{title:"Database CheatSheet",permalink:"/docs/cheatsheet/fundamental/database"},next:{title:"Hash & Map Cheatsheet",permalink:"/docs/cheatsheet/algorithm/hash-map"}},l={},s=[{value:"Concurrency",id:"concurrency",level:3},{value:"Context",id:"context",level:3},{value:"Garbage Collection",id:"garbage-collection",level:3},{value:"Pointer",id:"pointer",level:3},{value:"Slice and Array",id:"slice-and-array",level:3},{value:"Structs and Interfaces",id:"structs-and-interfaces",level:3}],u={toc:s},m="wrapper";function d(e){let{components:n,...t}=e;return(0,a.kt)(m,(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h3",{id:"concurrency"},"Concurrency"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Goroutine: Lightweight threads managed by the Go runtime, enabling concurrent execution."),(0,a.kt)("li",{parentName:"ul"},"Channel (chan): Facilitates communication and synchronization between goroutines by passing messages."),(0,a.kt)("li",{parentName:"ul"},"Mutex (sync.Mutex): Ensures mutual exclusion, preventing concurrent access to shared resources."),(0,a.kt)("li",{parentName:"ul"},"select Statement: Waits on multiple channel operations, proceeding with whichever is ready first."),(0,a.kt)("li",{parentName:"ul"},"WaitGroup (sync.WaitGroup): Waits for a collection of goroutines to finish executing.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "sync"\n    "time"\n)\n\nfunc main() {\n    var wg sync.WaitGroup       // WaitGroup to wait for goroutines to finish\n    var mu sync.Mutex           // Mutex to protect shared resource\n    counter := 0                // Shared resource\n    ch := make(chan int, 5)     // Buffered channel\n\n    // Goroutine to send data to the channel\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        for i := 1; i <= 5; i++ {\n            ch <- i\n            fmt.Printf("Sent: %d\\n", i)\n            time.Sleep(100 * time.Millisecond)\n        }\n        close(ch) // Close channel after sending all data\n    }()\n\n    // Goroutine to receive data from the channel\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        for num := range ch {\n            mu.Lock()\n            counter += num\n            fmt.Printf("Received: %d, Counter: %d\\n", num, counter)\n            mu.Unlock()\n            time.Sleep(150 * time.Millisecond)\n        }\n    }()\n\n    // Using select to handle channel operations\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        for {\n            select {\n            case num, ok := <-ch:\n                if !ok {\n                    return\n                }\n                fmt.Printf("Select received: %d\\n", num)\n            default:\n                fmt.Println("No data available, doing other work...")\n                time.Sleep(50 * time.Millisecond)\n            }\n        }\n    }()\n\n    // Wait for all goroutines to finish\n    wg.Wait()\n    fmt.Printf("Final Counter: %d\\n", counter)\n}\n\n// Output:\n// Sent: 1\n// Received: 1, Counter: 1\n// Select received: 1\n// Sent: 2\n// Received: 2, Counter: 3\n// Select received: 2\n// Sent: 3\n// Received: 3, Counter: 6\n// Select received: 3\n// Sent: 4\n// Received: 4, Counter: 10\n// Select received: 4\n// Sent: 5\n// Received: 5, Counter: 15\n// Select received: 5\n// Final Counter: 15\n')),(0,a.kt)("h3",{id:"context"},"Context"),(0,a.kt)("p",null,"The context package in Go provides a way to carry deadlines, cancellation signals, and other request-scoped values across API boundaries and goroutines."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Background: The root context, typically used in main functions, initialization, and tests."),(0,a.kt)("li",{parentName:"ul"},"TODO: A placeholder context, used when you're unsure which context to use."),(0,a.kt)("li",{parentName:"ul"},"WithCancel: Derives a new context that can be canceled."),(0,a.kt)("li",{parentName:"ul"},"WithDeadline: Derives a new context that will automatically be canceled at a specified time."),(0,a.kt)("li",{parentName:"ul"},"WithTimeout: Derives a new context that will automatically be canceled after a specified duration."),(0,a.kt)("li",{parentName:"ul"},"WithValue: Derives a new context that carries a key-value pair.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "context"\n    "fmt"\n    "time"\n)\n\nfunc main() {\n    // 1. Background Context\n    bg := context.Background()\n\n    // 2. TODO Context\n    todo := context.TODO()\n\n    fmt.Println("Background Context:", bg)\n    fmt.Println("TODO Context:", todo)\n\n    // 3. WithCancel\n    ctx, cancel := context.WithCancel(bg)\n    go func() {\n        time.Sleep(2 * time.Second)\n        fmt.Println("Canceling context")\n        cancel()\n    }()\n\n    select {\n    case <-ctx.Done():\n        fmt.Println("Context canceled:", ctx.Err())\n    }\n\n    // 4. WithTimeout\n    ctxTimeout, cancelTimeout := context.WithTimeout(bg, 1*time.Second)\n    defer cancelTimeout()\n\n    select {\n    case <-time.After(2 * time.Second):\n        fmt.Println("Operation completed")\n    case <-ctxTimeout.Done():\n        fmt.Println("Timeout:", ctxTimeout.Err())\n    }\n\n    // 5. WithDeadline\n    deadline := time.Now().Add(1 * time.Second)\n    ctxDeadline, cancelDeadline := context.WithDeadline(bg, deadline)\n    defer cancelDeadline()\n\n    select {\n    case <-time.After(2 * time.Second):\n        fmt.Println("Operation completed")\n    case <-ctxDeadline.Done():\n        fmt.Println("Deadline reached:", ctxDeadline.Err())\n    }\n\n    // 6. WithValue\n    type key string\n    ctxValue := context.WithValue(bg, key("userID"), 42)\n    processRequest(ctxValue)\n}\n\nfunc processRequest(ctx context.Context) {\n    userID, ok := ctx.Value("userID").(int)\n    if !ok {\n        fmt.Println("No user ID found")\n        return\n    }\n    fmt.Printf("Processing request for user ID: %d\\n", userID)\n}\n\n// Output\n// Background Context: context.Background\n// TODO Context: context.TODO\n// Canceling context\n// Context canceled: context canceled\n// Timeout: context deadline exceeded\n// Deadline reached: context deadline exceeded\n// Processing request for user ID: 42\n')),(0,a.kt)("h3",{id:"garbage-collection"},"Garbage Collection"),(0,a.kt)("p",null,"Go features an automatic garbage collector that manages memory by reclaiming memory occupied by objects that are no longer in use. This eliminates the need for manual memory management, reducing the likelihood of memory leaks and other related issues."),(0,a.kt)("p",null,"The runtime.GC() function is called to force garbage collection, reclaiming the memory occupied by the slice."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "runtime"\n    "time"\n)\n\nfunc main() {\n    // Display memory stats before allocation\n    var m runtime.MemStats\n    runtime.ReadMemStats(&m)\n    fmt.Printf("Before allocation: Alloc = %v KB\\n", m.Alloc/1024)\n\n    // Allocate memory\n    allocateMemory()\n\n    // Force garbage collection\n    runtime.GC()\n\n    // Display memory stats after GC\n    runtime.ReadMemStats(&m)\n    fmt.Printf("After GC: Alloc = %v KB\\n", m.Alloc/1024)\n}\n\nfunc allocateMemory() {\n    // Allocate a large slice to consume memory\n    slice := make([]byte, 10*1024*1024) // 10 MB\n    for i := range slice {\n        slice[i] = byte(i % 256)\n    }\n    fmt.Println("Allocated 10 MB of memory")\n    // The slice goes out of scope after this function\n}\n\n// Output:\n// Before allocation: Alloc = 1234 KB\n// Allocated 10 MB of memory\n// After GC: Alloc = 1234 KB\n')),(0,a.kt)("h3",{id:"pointer"},"Pointer"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n)\n\nfunc main() {\n    a := 10\n    fmt.Printf("Initial value of a: %d\\n", a)\n\n    // Create a pointer to a\n    b := &a\n    fmt.Printf("Pointer b points to a: %d\\n", *b)\n\n    // Modify a via pointer\n    *b = 20\n    fmt.Printf("After modifying via pointer, a: %d\\n", a)\n\n    // Pointer to a pointer\n    c := &b\n    fmt.Printf("Pointer c points to b: %p\\n", c)\n    fmt.Printf("Value pointed by c: %d\\n", **c)\n\n    // Passing pointer to a function\n    increment(&a)\n    fmt.Printf("After incrementing via function, a: %d\\n", a)\n}\n\nfunc increment(n *int) {\n    *n++\n    fmt.Printf("Value inside increment function: %d\\n", *n)\n}\n\n// Output:\n// Initial value of a: 10\n// Pointer b points to a: 10\n// After modifying via pointer, a: 20\n// Pointer c points to b: 0xc0000160b8\n// Value pointed by c: 20\n// Value inside increment function: 21\n// After incrementing via function, a: 21\n')),(0,a.kt)("h3",{id:"slice-and-array"},"Slice and Array"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Arrays: Fixed-size, ordered collections of elements of the same type. The size is part of the array's type."),(0,a.kt)("li",{parentName:"ul"},"Slices: Dynamic, flexible views into arrays. They provide more powerful and convenient features compared to arrays, such as dynamic sizing.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n)\n\nfunc main() {\n    // Arrays\n    var array [3]string\n    array[0] = "Apple"\n    array[1] = "Banana"\n    array[2] = "Cherry"\n    fmt.Println("Array:", array)\n\n    // Slices\n    slice := []string{"Dog", "Elephant"}\n    fmt.Println("Initial Slice:", slice)\n\n    // Append to slice\n    slice = append(slice, "Frog")\n    fmt.Println("After Append:", slice)\n\n    // Slice capacity and length\n    fmt.Printf("Slice Length: %d, Capacity: %d\\n", len(slice), cap(slice))\n\n    // Creating a slice from an array\n    subSlice := array[1:3]\n    fmt.Println("Sub-slice from array:", subSlice)\n\n    // Iterating over a slice\n    fmt.Println("Iterating over slice:")\n    for index, value := range slice {\n        fmt.Printf("Index %d: %s\\n", index, value)\n    }\n\n    // Using make to create a slice\n    madeSlice := make([]int, 5, 10) // length 5, capacity 10\n    for i := 0; i < len(madeSlice); i++ {\n        madeSlice[i] = i * 2\n    }\n    fmt.Println("Made Slice:", madeSlice)\n    fmt.Printf("Made Slice Length: %d, Capacity: %d\\n", len(madeSlice), cap(madeSlice))\n}\n\n// Output:\n// Array: [Apple Banana Cherry]\n// Initial Slice: [Dog Elephant]\n// After Append: [Dog Elephant Frog]\n// Slice Length: 3, Capacity: 6\n// Sub-slice from array: [Banana Cherry]\n// Iterating over slice:\n// Index 0: Dog\n// Index 1: Elephant\n// Index 2: Frog\n// Made Slice: [0 2 4 6 8]\n// Made Slice Length: 5, Capacity: 10\n')),(0,a.kt)("h3",{id:"structs-and-interfaces"},"Structs and Interfaces"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Structs: Composite data types that group together variables under a single name. They are used to create complex data structures."),(0,a.kt)("li",{parentName:"ul"},"Interfaces: Define a set of method signatures. Types that implement these methods satisfy the interface, enabling polymorphism and flexible code design.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n)\n\n// Struct definition\ntype Person struct {\n    Name string\n    Age  int\n}\n\n// Interface definition\ntype Greeter interface {\n    Greet()\n}\n\n// Implementing the Greeter interface for Person\nfunc (p Person) Greet() {\n    fmt.Printf("Hello, my name is %s and I am %d years old.\\n", p.Name, p.Age)\n}\n\n// Another struct implementing Greeter\ntype Robot struct {\n    ID string\n}\n\n// Implementing the Greeter interface for Robot\nfunc (r Robot) Greet() {\n    fmt.Printf("Beep boop. I am robot #%s.\\n", r.ID)\n}\n\nfunc main() {\n    // Creating instances of structs\n    p := Person{Name: "Alice", Age: 30}\n    r := Robot{ID: "RX-78"}\n\n    // Using structs directly\n    p.Greet()\n    r.Greet()\n\n    // Using interface to hold different types\n    var g Greeter\n\n    g = p\n    g.Greet()\n\n    g = r\n    g.Greet()\n\n    // Slice of Greeters\n    greeters := []Greeter{p, r}\n    fmt.Println("Iterating over Greeters:")\n    for _, greeter := range greeters {\n        greeter.Greet()\n    }\n}\n')))}d.isMDXComponent=!0}}]);