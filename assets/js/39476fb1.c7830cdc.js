"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9061],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>k});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),m=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=m(e.components);return n.createElement(c.Provider,{value:t},e.children)},p="mdxType",s={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=m(r),h=a,k=p["".concat(c,".").concat(h)]||p[h]||s[h]||o;return r?n.createElement(k,i(i({ref:t},u),{},{components:r})):n.createElement(k,i({ref:t},u))}));function k(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=h;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[p]="string"==typeof e?e:a,i[1]=l;for(var m=2;m<o;m++)i[m]=r[m];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},7326:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>s,frontMatter:()=>o,metadata:()=>l,toc:()=>m});var n=r(7462),a=(r(7294),r(3905));const o={title:"Automated Market Maker"},i=void 0,l={unversionedId:"programming/blockchain/amm",id:"programming/blockchain/amm",title:"Automated Market Maker",description:"The Automated Market Maker (AMM) algorithm uses the formula x \\* y = k.",source:"@site/docs/programming/blockchain/amm.md",sourceDirName:"programming/blockchain",slug:"/programming/blockchain/amm",permalink:"/docs/programming/blockchain/amm",draft:!1,tags:[],version:"current",frontMatter:{title:"Automated Market Maker"},sidebar:"programming",previous:{title:"Analytics",permalink:"/docs/programming/aws/analytics"},next:{title:"Blockchain Consensus",permalink:"/docs/programming/blockchain/consensus"}},c={},m=[],u={toc:m},p="wrapper";function s(e){let{components:t,...r}=e;return(0,a.kt)(p,(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The Automated Market Maker (AMM) algorithm uses the formula x ","*"," y = k."),(0,a.kt)("p",null,"For example:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We have a pool with 50 BUSD tokens and 50 NEW tokens."),(0,a.kt)("li",{parentName:"ul"},"According to the formula, we have 50 * 50 = 2500."),(0,a.kt)("li",{parentName:"ul"},"Kori adds 5 BUSD to the pool."),(0,a.kt)("li",{parentName:"ul"},"Now the pool will have 55 * 50 = 2750."),(0,a.kt)("li",{parentName:"ul"},"To maintain the initial value of k, which is 2500, we must exchange a corresponding - amount of NEW tokens."),(0,a.kt)("li",{parentName:"ul"},"KORI receives: 50 - (2500 / 55) = 4.54 NEW."),(0,a.kt)("li",{parentName:"ul"},"Now the pool will have 55 * 45.46 = 2500, equivalent to the initial value of k.")),(0,a.kt)("p",null,"So, the AMM algorithm uses the x * y = k formula to maintain balance within the token pool. When there is a change in the number of tokens in the pool (e.g., adding BUSD), the algorithm calculates the corresponding amount of tokens to be added or removed (in this case, NEW tokens) to keep the k value unchanged. This helps the system maintain stability and balance."),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/quankori/quankori.github.io/master/src/images/blockchain/2.PNG",alt:"Image"})))}s.isMDXComponent=!0}}]);