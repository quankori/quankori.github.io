"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6542],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return n?r.createElement(h,s(s({ref:t},u),{},{components:n})):r.createElement(h,s({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3538:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={title:"Node.js Concept"},s=void 0,i={unversionedId:"programming/nodejs/concept",id:"programming/nodejs/concept",title:"Node.js Concept",description:"Node.js structure",source:"@site/docs/programming/nodejs/concept.md",sourceDirName:"programming/nodejs",slug:"/programming/nodejs/concept",permalink:"/docs/programming/nodejs/concept",draft:!1,tags:[],version:"current",frontMatter:{title:"Node.js Concept"},sidebar:"programming",previous:{title:"Go Concept",permalink:"/docs/programming/go/concept"}},l={},c=[{value:"Node.js structure",id:"nodejs-structure",level:2},{value:"Single thread in Node.js",id:"single-thread-in-nodejs",level:2},{value:"Node.js Fundamentals:",id:"nodejs-fundamentals",level:2},{value:"Comparison:",id:"comparison",level:2},{value:"1. Concurrency Model:",id:"1-concurrency-model",level:3},{value:"2. Memory Consumption:",id:"2-memory-consumption",level:3},{value:"3. Complexity:",id:"3-complexity",level:3},{value:"4. Scalability:",id:"4-scalability",level:3},{value:"Child process",id:"child-process",level:2},{value:"Worker threads",id:"worker-threads",level:2},{value:"Event loop",id:"event-loop",level:2},{value:"Cluster mode",id:"cluster-mode",level:2},{value:"PM2",id:"pm2",level:2},{value:"process.nextTick() v\xe0 setImmediate()",id:"processnexttick-v\xe0-setimmediate",level:2}],u={toc:c},d="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"nodejs-structure"},"Node.js structure"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"V8 is used to interpret and execute Javascript code"),(0,a.kt)("li",{parentName:"ul"},"Libuv is used for accessing the filesystem and some aspects of concurrency")),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/quankori/quankori.github.io/master/src/images/programming/3.PNG",alt:"Image"})),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/quankori/quankori.github.io/master/src/images/programming/4.PNG",alt:"Image"})),(0,a.kt)("h2",{id:"single-thread-in-nodejs"},"Single thread in Node.js"),(0,a.kt)("h1",{id:"nodejs-single-threaded-vs-multi-threaded-in-other-languages"},"Node.js Single-threaded vs. Multi-threaded in Other Languages"),(0,a.kt)("p",null,"Node.js primarily functions as a single-threaded runtime environment. However, it has features to handle concurrent operations efficiently. Let's dive deeper:"),(0,a.kt)("h2",{id:"nodejs-fundamentals"},"Node.js Fundamentals:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Event Loop & Non-Blocking I/O"),": Node.js achieves high concurrency using an event loop paired with non-blocking I/O. While JavaScript code runs on a single thread, many operations, especially I/O, are offloaded, allowing the main thread to process other tasks without waiting. This mechanism makes Node.js efficient for I/O-bound applications."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Worker Threads"),': Node.js introduced the "worker_threads" module from version 10.5.0, which provides the ability to run JavaScript in parallel threads, enhancing its capability to handle CPU-bound tasks.')),(0,a.kt)("h2",{id:"comparison"},"Comparison:"),(0,a.kt)("h3",{id:"1-concurrency-model"},"1. Concurrency Model:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Node.js (Single-threaded)"),": Relies on an event-driven, non-blocking I/O model, suitable for I/O-bound tasks. CPU-bound tasks can pose a challenge unless using worker threads or clustering."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Other Languages (Multi-threaded)"),": Languages like Java or C# use multi-threading, which caters efficiently to both I/O-bound and CPU-bound tasks. However, they introduce challenges such as thread synchronization and potential deadlocks.")),(0,a.kt)("h3",{id:"2-memory-consumption"},"2. Memory Consumption:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Node.js"),": Typically lower since there's no need for multiple threads per connection. Yet, one must ensure the event loop isn't blocked to maintain performance."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Multi-threaded Languages"),": Might have a higher footprint as each thread maintains its own stack, but can distribute CPU-bound tasks effectively.")),(0,a.kt)("h3",{id:"3-complexity"},"3. Complexity:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Node.js"),": Generally simpler in terms of concurrency management. One doesn't have to manage thread synchronization in most scenarios. The primary concern is to avoid blocking the event loop."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Multi-threaded Languages"),": Can be complex due to explicit thread management, synchronization issues, and potential deadlocks.")),(0,a.kt)("h3",{id:"4-scalability"},"4. Scalability:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Node.js"),": Scales horizontally by adding more instances. Achievable through tools like the cluster module or container orchestration utilities."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Multi-threaded Languages"),": Can scale both vertically (adding threads) and horizontally (adding machines).")),(0,a.kt)("p",null,'Node.js can indeed operate in a multi-threaded fashion with the "worker_threads" module. However, its primary design is single-threaded. Implementing multiple threads in Node.js brings forth the challenges typical of multi-threaded programming in other languages.'),(0,a.kt)("h2",{id:"child-process"},"Child process"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Allows you to run a new process on the system and interact with it through pipes. Child processes do not share memory or resources with each other, and each child process uses a separate thread. Child processes are useful for tasks that require processing multiple processes, but require interaction between independent processes.")),(0,a.kt)("h2",{id:"worker-threads"},"Worker threads"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Worker threads are a new feature in Node.js 10.5, allowing you to create multiple threads within a single Node.js process. All worker threads share memory and resources with the main thread, but each worker thread runs on a separate thread. Worker threads make it easier to create multithreaded applications in Node.js.")),(0,a.kt)("h2",{id:"event-loop"},"Event loop"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"When an asynchronous request is sent, such as an HTTP request, Node.js does not wait for that request to complete before continuing to execute other requests. Instead, Node.js sends that request to the system and continues to execute other requests. When that request is completed, the system notifies Node.js that the request is complete, and Node.js continues to execute other tasks.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Tasks in the event loop are queued in different queues, including:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Task queue (also known as a callback queue): Contains callback functions called when an asynchronous request ends.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Microtask queue: Contains callback functions called when a promise is resolved or rejected.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Timers queue: Contains callback functions called when a time or timer (timeout or interval) is activated.")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"When the event loop starts, it executes tasks in the microtask queue first, then the task queue, and finally the timers queue.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"When a task is executed, Node.js puts it into an infinite loop to wait for other tasks. While waiting, Node.js continues to execute tasks in the event loop queue."))),(0,a.kt)("h2",{id:"cluster-mode"},"Cluster mode"),(0,a.kt)("p",null,"Cluster mode is a feature in Node.js that allows you to create multiple child processes to run the same Node.js application on a computer or network. Each child process can run on a separate CPU or core, so it can take advantage of the power of CPUs or cores in the system."),(0,a.kt)("p",null,"In Cluster mode, the master process is responsible for creating and managing the worker processes. The master process shares TCP and UDP connections with the worker processes, allowing them to share network connections and process requests concurrently. When a request is received, the master process distributes the request to one of the available worker processes."),(0,a.kt)("h2",{id:"pm2"},"PM2"),(0,a.kt)("p",null,"PM2 (Process Manager 2) is a process management tool for Node.js that provides many useful features for running and managing Node.js applications on a server or in a production environment. PM2 can help manage Node.js processes, restart processes that have crashed, monitor system resources, log events, and much more."),(0,a.kt)("h2",{id:"processnexttick-v\xe0-setimmediate"},"process.nextTick() v\xe0 setImmediate()"),(0,a.kt)("p",null,"process.nextTick() and setImmediate() are both methods used for scheduling callbacks. The difference between them is that process.nextTick() is called immediately after the current function ends, while setImmediate() is called after the system has processed all scheduled I/O. Therefore, process.nextTick() may be prioritized in cases where a quick response is necessary and I/O blocking should be avoided."))}p.isMDXComponent=!0}}]);