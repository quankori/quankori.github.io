"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7149],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>k});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),c=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(i.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),d=r,k=u["".concat(i,".").concat(d)]||u[d]||m[d]||l;return t?a.createElement(k,o(o({ref:n},p),{},{components:t})):a.createElement(k,o({ref:n},p))}));function k(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,o=new Array(l);o[0]=d;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<l;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7967:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const l={title:"Lock Transaction"},o=void 0,s={unversionedId:"programming/database/lock-transaction",id:"programming/database/lock-transaction",title:"Lock Transaction",description:"Lock Transactions in Databases",source:"@site/docs/programming/database/lock-transaction.md",sourceDirName:"programming/database",slug:"/programming/database/lock-transaction",permalink:"/docs/programming/database/lock-transaction",draft:!1,tags:[],version:"current",frontMatter:{title:"Lock Transaction"},sidebar:"programming",previous:{title:"Indexes Database",permalink:"/docs/programming/database/indexes"},next:{title:"Redis",permalink:"/docs/programming/database/redis"}},i={},c=[{value:"Lock Transactions in Databases",id:"lock-transactions-in-databases",level:2},{value:"Why Locks are Necessary",id:"why-locks-are-necessary",level:2},{value:"Types of Locks",id:"types-of-locks",level:2},{value:"1. Shared Lock (S)",id:"1-shared-lock-s",level:3},{value:"2. Exclusive Lock (X)",id:"2-exclusive-lock-x",level:3},{value:"3. Intent Locks",id:"3-intent-locks",level:3},{value:"4. Row-Level Locks",id:"4-row-level-locks",level:3},{value:"5. Table-Level Locks",id:"5-table-level-locks",level:3},{value:"6. Deadlocks",id:"6-deadlocks",level:3},{value:"Isolation Levels in Transactions",id:"isolation-levels-in-transactions",level:2},{value:"1. Read Uncommitted",id:"1-read-uncommitted",level:3},{value:"2. Read Committed",id:"2-read-committed",level:3},{value:"3. Repeatable Read",id:"3-repeatable-read",level:3},{value:"4. Serializable",id:"4-serializable",level:3},{value:"Examples in NestJS (TypeORM) and Go (GORM)",id:"examples-in-nestjs-typeorm-and-go-gorm",level:2},{value:"Example in NestJS with TypeORM",id:"example-in-nestjs-with-typeorm",level:3},{value:"Example in Go with GORM",id:"example-in-go-with-gorm",level:3},{value:"Summary",id:"summary",level:2}],p={toc:c},u="wrapper";function m(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"lock-transactions-in-databases"},"Lock Transactions in Databases"),(0,r.kt)("p",null,"Locks are mechanisms used in database systems to ensure data consistency and integrity during concurrent transactions. They prevent conflicts when multiple transactions try to read or write the same data simultaneously. Understanding how locks work and their different types is crucial for designing robust and high-performance database applications."),(0,r.kt)("h2",{id:"why-locks-are-necessary"},"Why Locks are Necessary"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Data Integrity"),": Ensure that concurrent transactions do not lead to inconsistent or incorrect data."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Isolation"),": Maintain the isolation property of transactions, ensuring that the intermediate states of a transaction are not visible to other transactions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Concurrency Control"),": Allow multiple transactions to proceed concurrently without interfering with each other.")),(0,r.kt)("h2",{id:"types-of-locks"},"Types of Locks"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Shared Lock (S)")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Exclusive Lock (X)")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Intent Locks")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Row-Level Locks")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Table-Level Locks")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Deadlocks"))),(0,r.kt)("h3",{id:"1-shared-lock-s"},"1. Shared Lock (S)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Allows multiple transactions to read a resource but not modify it."),(0,r.kt)("li",{parentName:"ul"},"Multiple transactions can hold a shared lock on the same resource simultaneously.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Case"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Reading data from a table.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- Transaction 1\nBEGIN TRANSACTION;\nSELECT * FROM accounts WHERE account_id = 123; -- Acquires a shared lock\n\n-- Transaction 2\nBEGIN TRANSACTION;\nSELECT * FROM accounts WHERE account_id = 123; -- Also acquires a shared lock\n")),(0,r.kt)("h3",{id:"2-exclusive-lock-x"},"2. Exclusive Lock (X)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Allows a transaction to read and modify a resource."),(0,r.kt)("li",{parentName:"ul"},"No other transaction can hold a lock on the same resource while an exclusive lock is held.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Case"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Updating or deleting data in a table.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- Transaction 1\nBEGIN TRANSACTION;\nUPDATE accounts SET balance = balance + 100 WHERE account_id = 123; -- Acquires an exclusive lock\n\n-- Transaction 2\nBEGIN TRANSACTION;\nSELECT * FROM accounts WHERE account_id = 123; -- Blocked until Transaction 1 releases the lock\n")),(0,r.kt)("h3",{id:"3-intent-locks"},"3. Intent Locks"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Indicate a transaction's intention to acquire a shared or exclusive lock on a resource."),(0,r.kt)("li",{parentName:"ul"},"Used to manage locks in hierarchical structures (e.g., database, table, row).")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Types"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Intent Shared (IS)"),": Indicates intention to acquire shared locks."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Intent Exclusive (IX)"),": Indicates intention to acquire exclusive locks."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Shared with Intent Exclusive (SIX)"),": A combination of shared and intent exclusive locks.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- Acquiring intent locks\nLOCK TABLE accounts IN SHARE MODE; -- Intent shared lock\nLOCK TABLE accounts IN EXCLUSIVE MODE; -- Intent exclusive lock\n")),(0,r.kt)("h3",{id:"4-row-level-locks"},"4. Row-Level Locks"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Locks specific rows in a table, allowing higher concurrency compared to table-level locks.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Case"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Updating specific rows in a large table without blocking access to other rows.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- Transaction 1\nBEGIN TRANSACTION;\nUPDATE accounts SET balance = balance + 100 WHERE account_id = 123; -- Row-level lock on account_id = 123\n\n-- Transaction 2\nBEGIN TRANSACTION;\nUPDATE accounts SET balance = balance + 100 WHERE account_id = 124; -- Row-level lock on account_id = 124\n")),(0,r.kt)("h3",{id:"5-table-level-locks"},"5. Table-Level Locks"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Locks an entire table, preventing other transactions from accessing any rows in the table.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use Case"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Operations that affect the entire table (e.g., altering the table structure).")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- Transaction 1\nBEGIN TRANSACTION;\nLOCK TABLE accounts IN EXCLUSIVE MODE; -- Table-level lock\n\n-- Transaction 2\nBEGIN TRANSACTION;\nSELECT * FROM accounts; -- Blocked until Transaction 1 releases the lock\n")),(0,r.kt)("h3",{id:"6-deadlocks"},"6. Deadlocks"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A situation where two or more transactions are waiting for each other to release locks, resulting in a cycle of dependencies and blocking all involved transactions.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Detection and Resolution"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"DBMSs use deadlock detection algorithms to identify deadlocks and resolve them by rolling back one or more transactions.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"-- Transaction 1\nBEGIN TRANSACTION;\nUPDATE accounts SET balance = balance + 100 WHERE account_id = 123; -- Acquires exclusive lock on account_id = 123\nUPDATE accounts SET balance = balance - 100 WHERE account_id = 124; -- Waits for lock held by Transaction 2\n\n-- Transaction 2\nBEGIN TRANSACTION;\nUPDATE accounts SET balance = balance + 100 WHERE account_id = 124; -- Acquires exclusive lock on account_id = 124\nUPDATE accounts SET balance = balance - 100 WHERE account_id = 123; -- Waits for lock held by Transaction 1\n")),(0,r.kt)("h2",{id:"isolation-levels-in-transactions"},"Isolation Levels in Transactions"),(0,r.kt)("p",null,"Isolation levels determine the degree to which the operations in one transaction are isolated from those in other concurrent transactions. Different isolation levels help balance between performance and consistency. The four standard isolation levels are:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Read Uncommitted")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Read Committed")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Repeatable Read")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Serializable"))),(0,r.kt)("h3",{id:"1-read-uncommitted"},"1. Read Uncommitted"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Transactions can read data that has been modified but not yet committed by other transactions."),(0,r.kt)("li",{parentName:"ul"},"This isolation level allows dirty reads.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example Issues"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Dirty Read"),": A transaction reads data written by another transaction that has not yet committed.")),(0,r.kt)("h3",{id:"2-read-committed"},"2. Read Committed"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Transactions can only read data that has been committed."),(0,r.kt)("li",{parentName:"ul"},"This isolation level prevents dirty reads but allows non-repeatable reads.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example Issues"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Non-repeatable Read"),": A transaction reads the same row twice and gets different data each time because another transaction modified the data between the reads.")),(0,r.kt)("h3",{id:"3-repeatable-read"},"3. Repeatable Read"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Ensures that if a transaction reads a row, subsequent reads of the same row will return the same data."),(0,r.kt)("li",{parentName:"ul"},"This isolation level prevents dirty reads and non-repeatable reads but allows phantom reads.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example Issues"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Phantom Read"),": A transaction reads a set of rows that satisfy a condition, but another transaction inserts or deletes rows that satisfy the condition, leading to different results in subsequent reads.")),(0,r.kt)("h3",{id:"4-serializable"},"4. Serializable"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The highest isolation level, ensuring complete isolation from other transactions."),(0,r.kt)("li",{parentName:"ul"},"This isolation level prevents dirty reads, non-repeatable reads, and phantom reads.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example Issues"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"None"),": Serializable transactions are fully isolated but can result in reduced concurrency and performance.")),(0,r.kt)("h2",{id:"examples-in-nestjs-typeorm-and-go-gorm"},"Examples in NestJS (TypeORM) and Go (GORM)"),(0,r.kt)("h3",{id:"example-in-nestjs-with-typeorm"},"Example in NestJS with TypeORM"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"1. Install Dependencies"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install @nestjs/typeorm typeorm mysql\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"2. Set Up TypeORM Configuration"),":\nCreate a ",(0,r.kt)("inlineCode",{parentName:"p"},"typeorm.config.ts")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import { TypeOrmModuleOptions } from "@nestjs/typeorm";\n\nexport const typeOrmConfig: TypeOrmModuleOptions = {\n  type: "mysql",\n  host: "localhost",\n  port: 3306,\n  username: "root",\n  password: "password",\n  database: "test_db",\n  entities: [__dirname + "/../**/*.entity.{js,ts}"],\n  synchronize: true,\n};\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3. Transaction with Isolation Levels"),":\nIn a service file, you can use TypeORM's ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryRunner")," to manage transactions with isolation levels."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import { Injectable } from "@nestjs/common";\nimport { InjectRepository } from "@nestjs/typeorm";\nimport {\n  Repository,\n  QueryRunner,\n  getConnection,\n  IsolationLevel,\n} from "typeorm";\nimport { User } from "./user.entity";\n\n@Injectable()\nexport class UserService {\n  constructor(\n    @InjectRepository(User)\n    private userRepository: Repository<User>\n  ) {}\n\n  async transferFunds(\n    senderId: number,\n    receiverId: number,\n    amount: number\n  ): Promise<void> {\n    const queryRunner: QueryRunner = getConnection().createQueryRunner();\n    await queryRunner.connect();\n    await queryRunner.startTransaction(IsolationLevel.REPEATABLE_READ);\n\n    try {\n      const sender = await queryRunner.manager.findOne(User, senderId);\n      const receiver = await queryRunner.manager.findOne(User, receiverId);\n\n      if (sender.balance >= amount) {\n        sender.balance -= amount;\n        receiver.balance += amount;\n\n        await queryRunner.manager.save(sender);\n        await queryRunner.manager.save(receiver);\n\n        await queryRunner.commitTransaction();\n      } else {\n        throw new Error("Insufficient funds");\n      }\n    } catch (error) {\n      await queryRunner.rollbackTransaction();\n    } finally {\n      await queryRunner.release();\n    }\n  }\n}\n')),(0,r.kt)("h3",{id:"example-in-go-with-gorm"},"Example in Go with GORM"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"1. Install Dependencies"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"go get -u gorm.io/gorm\ngo get -u gorm.io/driver/mysql\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"2. Set Up GORM Configuration"),":\nCreate a ",(0,r.kt)("inlineCode",{parentName:"p"},"main.go")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "log"\n    "gorm.io/driver/mysql"\n    "gorm.io/gorm"\n)\n\ntype User struct {\n    ID      uint\n    Name    string\n    Balance float64\n}\n\nfunc main() {\n    dsn := "root:password@tcp(127.0.0.1:3306)/test_db?charset=utf8mb4&parseTime=True&loc=Local"\n    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    db.AutoMigrate(&User{})\n\n    transferFunds(db, 1, 2, 100.0)\n}\n\nfunc transferFunds(db *gorm.DB, senderID uint, receiverID uint, amount float64) {\n    err := db.Transaction(func(tx *gorm.DB) error {\n        var sender, receiver User\n\n        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).First(&sender, senderID).Error; err != nil {\n            return err\n        }\n        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).First(&receiver, receiverID).Error; err != nil {\n            return err\n        }\n\n        if sender.Balance >= amount {\n            sender.Balance -= amount\n            receiver.Balance += amount\n\n            if err := tx.Save(&sender).Error; err != nil {\n                return err\n            }\n            if err := tx.Save(&receiver).Error; err != nil {\n                return err\n            }\n        } else {\n            return fmt.Errorf("insufficient funds")\n        }\n\n        return nil\n    }, &sql.TxOptions{Isolation: sql.LevelRepeatableRead})\n\n    if err != nil {\n        log.Printf("Transfer failed: %v\\n", err)\n    } else {\n        log.Println("Transfer successful")\n    }\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3. Ensure to Import Required Packages"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "database/sql"\n    "gorm.io/gorm/clause"\n)\n')),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Isolation Levels"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Read Uncommitted"),": Allows dirty reads, least isolation."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Read Committed"),": Prevents dirty reads, allows non-repeatable reads."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Repeatable Read"),": Prevents dirty and non-repeatable reads, allows phantom reads."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Serializable"),": Prevents all anomalies, highest isolation."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Types"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Shared Lock (S)"),": Allows multiple transactions to read."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Exclusive Lock (X)"),": Allows one transaction to read and write."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Intent Locks"),": Indicate intention to acquire a specific type of lock."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Row-Level Locks"),": Lock specific rows for higher concurrency."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Table-Level Locks"),": Lock entire tables, useful for table-wide operations."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Deadlocks"),": Cycles of dependencies that block transactions, resolved by the DBMS.")))))}m.isMDXComponent=!0}}]);