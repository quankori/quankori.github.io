"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6800],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>d});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),c=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=c(e.components);return r.createElement(p.Provider,{value:t},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,d=u["".concat(p,".").concat(m)]||u[m]||f[m]||a;return n?r.createElement(d,i(i({ref:t},l),{},{components:n})):r.createElement(d,i({ref:t},l))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6548:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>f,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const a={title:"Types and Interfaces Typescript"},i=void 0,s={unversionedId:"programming/nodejs/types-interfaces",id:"programming/nodejs/types-interfaces",title:"Types and Interfaces Typescript",description:"In TypeScript, both type and interface are powerful ways to define the shape of an object or the structure of a piece of data. However, there are differences in their capabilities, usage, and when you might choose one over the other.",source:"@site/docs/programming/nodejs/types-interfaces.md",sourceDirName:"programming/nodejs",slug:"/programming/nodejs/types-interfaces",permalink:"/docs/programming/nodejs/types-interfaces",draft:!1,tags:[],version:"current",frontMatter:{title:"Types and Interfaces Typescript"},sidebar:"programming",previous:{title:"Generics",permalink:"/docs/programming/nodejs/generics"},next:{title:"Dependency Injection (DI)",permalink:"/docs/programming/nestjs/di"}},p={},c=[],l={toc:c},u="wrapper";function f(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In TypeScript, both type and interface are powerful ways to define the shape of an object or the structure of a piece of data. However, there are differences in their capabilities, usage, and when you might choose one over the other."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"type User = {\n  id: string;\n  name: string;\n} | null;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface User {\n  id: string;\n  name: string;\n}\n\ninterface Admin extends User {\n  permissions: string[];\n}\n")),(0,o.kt)("p",null,"Comparison and Use Cases:\n",(0,o.kt)("strong",{parentName:"p"},"For object shapes"),": Both type and interface can be used, but if you expect consumers of your code (like other developers) to extend, modify, or implement the object shape, interface is generally preferred due to its extensibility."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Extending"),": interface supports extending other interfaces using the extends keyword. While you can achieve a similar effect using intersection types with type, interface provides a more idiomatic OOP approach."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Union Types"),": If you need union types (like string | number), type is your only option."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Declaration Merging"),": Only interface supports declaration merging. This is useful when you want to piecemeal or gradually add to the shape of an object over multiple files or locations in a codebase."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Implementing in Classes"),": If you're defining a structure that a class will adhere to, use interface. This allows you to use the implements keyword with classes."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Performance"),": During compile time, interface is a bit faster because it doesn't require as much computational effort as type. This difference, however, is negligible for most projects."),(0,o.kt)("p",null,"In conclusion, while there's an overlap in many of their capabilities, the choice between type and interface depends on the specific use case. As a rule of thumb, for object shapes, especially ones that might be extended or implemented, interface is typically preferred. For more complex type definitions, unions, intersections, or mapped types, type is the go-to."))}f.isMDXComponent=!0}}]);