"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[743],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>k});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},m=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=c(t),g=a,k=p["".concat(s,".").concat(g)]||p[g]||u[g]||i;return t?r.createElement(k,l(l({ref:n},m),{},{components:t})):r.createElement(k,l({ref:n},m))}));function k(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=g;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[p]="string"==typeof e?e:a,l[1]=o;for(var c=2;c<i;c++)l[c]=t[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},1226:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=t(7462),a=(t(7294),t(3905));const i={title:"Golang"},l=void 0,o={unversionedId:"cheatsheet/programming/golang",id:"cheatsheet/programming/golang",title:"Golang",description:"Core Architecture",source:"@site/docs/cheatsheet/programming/golang.md",sourceDirName:"cheatsheet/programming",slug:"/cheatsheet/programming/golang",permalink:"/docs/cheatsheet/programming/golang",draft:!1,tags:[],version:"current",frontMatter:{title:"Golang"},sidebar:"cheatsheet",previous:{title:"Nest.js",permalink:"/docs/cheatsheet/programming/nestjs"},next:{title:"RxJS",permalink:"/docs/cheatsheet/programming/rxjs"}},s={},c=[{value:"Core Architecture",id:"core-architecture",level:2},{value:"Concurrency Service",id:"concurrency-service",level:3},{value:"Runtime Service",id:"runtime-service",level:3},{value:"Language Features Service",id:"language-features-service",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Memory Service",id:"memory-service",level:3},{value:"Concurrency Patterns Service",id:"concurrency-patterns-service",level:3},{value:"Benchmarking Service",id:"benchmarking-service",level:3}],m={toc:c},p="wrapper";function u(e){let{components:n,...t}=e;return(0,a.kt)(p,(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"core-architecture"},"Core Architecture"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Core architecture"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Concurrency model"),": Built-in support for concurrent execution.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Goroutines"),": Lightweight threads managed by Go runtime."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Channels"),": Communication pipes between goroutines."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Select statement"),": Multiplexes channel operations."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Runtime"),": Efficient execution environment.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Garbage collector"),": Low-latency memory management."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Scheduler"),": Manages goroutines with GOMAXPROCS."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Lightweight threads"),": Underpins goroutines."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Language features"),": Core syntax and design.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Static typing"),": Compile-time type checking."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Interfaces"),": Implicit implementation for flexibility."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Structs & methods"),": Object-like structures with behavior."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Error handling"),": Explicit error returns.")))),(0,a.kt)("h3",{id:"concurrency-service"},"Concurrency Service"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// src/core/concurrency.go (**Concurrency model**)\npackage core\n\nimport (\n    "fmt"\n    "time"\n)\n\ntype ConcurrencyService struct{}\n\nfunc (s *ConcurrencyService) RunGoroutine() {\n    go func() {\n        time.Sleep(1 * time.Second)\n        fmt.Println("Goroutine completed")\n    }()\n}\n\nfunc (s *ConcurrencyService) UseChannel() string {\n    ch := make(chan string)\n    go func() {\n        time.Sleep(1 * time.Second)\n        ch <- "Channel message"\n    }()\n    return <-ch\n}\n\nfunc (s *ConcurrencyService) UseSelect() string {\n    ch1 := make(chan string)\n    ch2 := make(chan string)\n    go func() {\n        time.Sleep(1 * time.Second)\n        ch1 <- "Message 1"\n    }()\n    go func() {\n        time.Sleep(2 * time.Second)\n        ch2 <- "Message 2"\n    }()\n    select {\n    case msg1 := <-ch1:\n        return msg1\n    case msg2 := <-ch2:\n        return msg2\n    case <-time.After(3 * time.Second):\n        return "Timeout"\n    }\n}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Concurrency Service Details"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Purpose"),": Demonstrates goroutines, channels, and select statements for concurrent execution."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Explanation"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"RunGoroutine")," launches a lightweight thread (goroutine) that runs asynchronously, ",(0,a.kt)("inlineCode",{parentName:"li"},"UseChannel")," sends and receives a message via a channel, and ",(0,a.kt)("inlineCode",{parentName:"li"},"UseSelect")," multiplexes between two channels with a timeout fallback."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Concurrency Model Details"),":",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Goroutines"),": Lightweight threads (2KB stack initially) managed by Go runtime, not OS threads, allowing thousands to run efficiently."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Channels"),": Typed pipes for safe communication between goroutines, avoiding race conditions (e.g., ",(0,a.kt)("inlineCode",{parentName:"li"},"ch <- data")," sends, ",(0,a.kt)("inlineCode",{parentName:"li"},"<-ch")," receives)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Select Statement"),": Waits on multiple channels, executing the first ready case, enabling non-blocking multiplexing.")))),(0,a.kt)("h3",{id:"runtime-service"},"Runtime Service"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// src/core/runtime.go (**Runtime**)\npackage core\n\nimport (\n    "fmt"\n    "runtime"\n)\n\ntype RuntimeService struct{}\n\nfunc (s *RuntimeService) TriggerGC() {\n    runtime.GC()\n    fmt.Println("Garbage collection triggered")\n}\n\nfunc (s *RuntimeService) SetSchedulerCores(cores int) {\n    runtime.GOMAXPROCS(cores)\n    fmt.Println("GOMAXPROCS set to:", runtime.GOMAXPROCS(0))\n}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Runtime Service Details"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Purpose"),": Manages garbage collection and scheduler settings."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Explanation"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"TriggerGC")," explicitly triggers garbage collection, while ",(0,a.kt)("inlineCode",{parentName:"li"},"SetSchedulerCores")," adjusts the number of OS threads used by the Go scheduler via ",(0,a.kt)("inlineCode",{parentName:"li"},"GOMAXPROCS"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Runtime Details"),":",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Garbage Collector"),": Low-latency, concurrent mark-and-sweep; runs when heap grows beyond threshold or manually triggered."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Scheduler"),": Manages goroutines across OS threads; ",(0,a.kt)("inlineCode",{parentName:"li"},"GOMAXPROCS")," sets thread count (defaults to CPU cores)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Lightweight Threads"),": Goroutines are multiplexed onto OS threads by the scheduler, reducing overhead.")))),(0,a.kt)("h3",{id:"language-features-service"},"Language Features Service"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// src/core/language.go (**Language features**)\npackage core\n\nimport "fmt"\n\ntype User struct {\n    ID   int\n    Name string\n}\n\ntype LanguageService struct{}\n\nfunc (s *LanguageService) CreateUser(id int, name string) User {\n    return User{ID: id, Name: name}\n}\n\nfunc (s *LanguageService) PrintUser(u User) error {\n    if u.ID <= 0 {\n        return fmt.Errorf("invalid ID: %d", u.ID)\n    }\n    fmt.Printf("User: %s (ID: %d)\\n", u.Name, u.ID)\n    return nil\n}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Language Features Service Details"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Purpose"),": Showcases structs, methods, and error handling."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Explanation"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"CreateUser")," returns a ",(0,a.kt)("inlineCode",{parentName:"li"},"User")," struct, while ",(0,a.kt)("inlineCode",{parentName:"li"},"PrintUser")," demonstrates method attachment and explicit error handling with a condition check."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Language Features Details"),":",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Static Typing"),": Compile-time type checking (e.g., ",(0,a.kt)("inlineCode",{parentName:"li"},"int"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Interfaces"),": Implicitly implemented (not shown here but common, e.g., ",(0,a.kt)("inlineCode",{parentName:"li"},"io.Reader"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Structs & Methods"),": Structs define data; methods attach behavior (e.g., ",(0,a.kt)("inlineCode",{parentName:"li"},"(s *LanguageService)"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Error Handling"),": Explicit via ",(0,a.kt)("inlineCode",{parentName:"li"},"error")," return type, no exceptions.")))),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"performance-optimization"},"Performance Optimization"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Performance optimization"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Memory management"),": Optimizes resource usage.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Stack vs heap allocation"),": Determines memory location."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Escape analysis"),": Optimizes allocation decisions."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Pprof profiling"),": Analyzes performance metrics."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Concurrency patterns"),": Leverages goroutines.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Worker pools"),": Distributes tasks across workers."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Fan-out/fan-in"),": Parallelizes and aggregates tasks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Pipeline"),": Chains data processing stages."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Benchmarking"),": Measures performance.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Go testing framework"),": Built-in benchmarking tools."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Pprof & trace"),": Detailed profiling and tracing."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Compilation"),": Produces efficient binaries.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Single binary output"),": Simplifies deployment."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Cross-compilation"),": Builds for multiple platforms."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Optimized machine code"),": High-performance execution.")))),(0,a.kt)("h3",{id:"memory-service"},"Memory Service"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// src/perf/memory.go (**Memory management**)\npackage perf\n\nimport (\n    "fmt"\n    "runtime/pprof"\n    "os"\n)\n\ntype MemoryService struct{}\n\nfunc (s *MemoryService) AllocateOnStack() int {\n    x := 42\n    return x\n}\n\nfunc (s *MemoryService) AllocateOnHeap() *int {\n    x := 42\n    return &x\n}\n\nfunc (s *MemoryService) ProfileMemory() {\n    f, _ := os.Create("mem.pprof")\n    pprof.WriteHeapProfile(f)\n    f.Close()\n    fmt.Println("Memory profile written to mem.pprof")\n}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Memory Service Details"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Purpose"),": Demonstrates stack vs heap allocation and pprof profiling."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Explanation"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"AllocateOnStack")," keeps ",(0,a.kt)("inlineCode",{parentName:"li"},"x")," on the stack (local, short-lived), ",(0,a.kt)("inlineCode",{parentName:"li"},"AllocateOnHeap")," forces ",(0,a.kt)("inlineCode",{parentName:"li"},"x")," to the heap via pointer return (escape analysis), and ",(0,a.kt)("inlineCode",{parentName:"li"},"ProfileMemory")," writes a heap profile to a file for analysis."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Memory Management Details"),":",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Stack vs Heap"),": Stack for local vars (fast, auto-cleaned); heap for pointers/shared data (GC-managed)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Escape Analysis"),": Compiler decides allocation; if a variable escapes (e.g., returned), it goes to heap."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Pprof Profiling"),": Captures heap usage (e.g., ",(0,a.kt)("inlineCode",{parentName:"li"},"go tool pprof mem.pprof"),").")))),(0,a.kt)("h3",{id:"concurrency-patterns-service"},"Concurrency Patterns Service"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// src/perf/concurrency.go (**Concurrency patterns**)\npackage perf\n\nimport (\n    "fmt"\n    "sync"\n)\n\ntype ConcurrencyPatternsService struct{}\n\nfunc (s *ConcurrencyPatternsService) WorkerPool(tasks []int) {\n    var wg sync.WaitGroup\n    for _, task := range tasks {\n        wg.Add(1)\n        go func(t int) {\n            defer wg.Done()\n            fmt.Println("Worker processed:", t)\n        }(task)\n    }\n    wg.Wait()\n}\n\nfunc (s *ConcurrencyPatternsService) FanOutFanIn(tasks []int) int {\n    var wg sync.WaitGroup\n    results := make(chan int, len(tasks))\n\n    for _, task := range tasks {\n        wg.Add(1)\n        go func(t int) {\n            defer wg.Done()\n            results <- t * 2\n        }(task)\n    }\n\n    go func() {\n        wg.Wait()\n        close(results)\n    }()\n\n    sum := 0\n    for result := range results {\n        sum += result\n    }\n    return sum\n}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Concurrency Patterns Service Details"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Purpose"),": Implements worker pools and fan-out/fan-in patterns."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Explanation"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"WorkerPool")," uses a WaitGroup to distribute tasks across goroutines, while ",(0,a.kt)("inlineCode",{parentName:"li"},"FanOutFanIn")," parallelizes tasks (fan-out) and aggregates results via a channel (fan-in)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Concurrency Patterns Details"),":",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Worker Pools"),": Limits concurrency by pooling goroutines."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Fan-out/Fan-in"),": Fans out tasks to workers, fans in results."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Pipeline"),": Not shown but chains stages (e.g., ",(0,a.kt)("inlineCode",{parentName:"li"},"chan -> chan -> chan"),").")))),(0,a.kt)("h3",{id:"benchmarking-service"},"Benchmarking Service"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// src/perf/benchmark.go (**Benchmarking**)\npackage perf\n\nimport "fmt"\n\ntype BenchmarkService struct{}\n\nfunc (s *BenchmarkService) Compute(n int) int {\n    sum := 0\n    for i := 0; i < n; i++ {\n        sum += i\n    }\n    fmt.Println("Computed sum:", sum)\n    return sum\n}\n\n// Benchmark example (run with `go test -bench=.`):\n// func BenchmarkCompute(b *testing.B) {\n//     s := BenchmarkService{}\n//     for i := 0; i < b.N; i++ {\n//         s.Compute(1000)\n//     }\n// }\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Benchmarking Service Details"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Purpose"),": Provides a method for benchmarking computation."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Explanation"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"Compute")," sums numbers up to ",(0,a.kt)("inlineCode",{parentName:"li"},"n"),", with a conceptual benchmark shown below (not executed here but runnable with ",(0,a.kt)("inlineCode",{parentName:"li"},"go test"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Benchmarking Details"),":",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Go Testing Framework"),": Built-in ",(0,a.kt)("inlineCode",{parentName:"li"},"testing")," package for benchmarks (e.g., ",(0,a.kt)("inlineCode",{parentName:"li"},"go test -bench=."),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Pprof & Trace"),": Profiles CPU/memory (e.g., ",(0,a.kt)("inlineCode",{parentName:"li"},"go tool pprof"),") and traces execution.")))))}u.isMDXComponent=!0}}]);