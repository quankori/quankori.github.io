"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[111],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>g});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},m=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=c(t),u=i,g=p["".concat(l,".").concat(u)]||p[u]||d[u]||o;return t?a.createElement(g,r(r({ref:n},m),{},{components:t})):a.createElement(g,r({ref:n},m))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},4872:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=t(7462),i=(t(7294),t(3905));const o={title:"Common Concepts"},r=void 0,s={unversionedId:"blog/database/common-concept",id:"blog/database/common-concept",title:"Common Concepts",description:"Overview: Common Concepts in databases define foundational principles for data organization, consistency, scalability, and performance, applicable across various database types like SQL and NoSQL, guiding design and optimization.",source:"@site/docs/blog/database/common-concept.md",sourceDirName:"blog/database",slug:"/blog/database/common-concept",permalink:"/blog/database/common-concept",draft:!1,tags:[],version:"current",frontMatter:{title:"Common Concepts"}},l={},c=[{value:"Data Models",id:"data-models",level:2},{value:"Data Models Service",id:"data-models-service",level:3},{value:"Consistency Models",id:"consistency-models",level:2},{value:"Consistency Models Service",id:"consistency-models-service",level:3},{value:"Scaling",id:"scaling",level:2},{value:"Scaling Service",id:"scaling-service",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Performance Optimization Service",id:"performance-optimization-service",level:3}],m={toc:c},p="wrapper";function d(e){let{components:n,...t}=e;return(0,i.kt)(p,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Overview"),": Common Concepts in databases define foundational principles for data organization, consistency, scalability, and performance, applicable across various database types like SQL and NoSQL, guiding design and optimization."),(0,i.kt)("h2",{id:"data-models"},"Data Models"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Data models"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Relational"),": Organizes data into tables with rows and columns (e.g., PostgreSQL)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"NoSQL"),": Flexible models like Document (MongoDB), Key-Value (Redis), Column-Family (Cassandra), or Graph (Neo4j)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Hybrid"),": Combines relational and NoSQL features (e.g., PostgreSQL with JSON).")),(0,i.kt)("h3",{id:"data-models-service"},"Data Models Service"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/datamodels/datamodels.service.ts (**Data models**)\nimport { Injectable } from "@nestjs/common";\nimport { Pool } from "pg";\nimport { MongoClient } from "mongodb";\nimport { Redis } from "ioredis";\n\n@Injectable()\nexport class DataModelsService {\n  private pgPool: Pool;\n  private mongoClient: MongoClient;\n  private redis: Redis;\n\n  constructor() {\n    this.pgPool = new Pool({\n      user: "postgres",\n      host: "localhost",\n      database: "mydb",\n      password: "password",\n      port: 5432,\n    });\n    this.mongoClient = new MongoClient("mongodb://localhost:27017");\n    this.redis = new Redis({ host: "localhost", port: 6379 });\n  }\n\n  async saveRelational(id: number, name: string): Promise<void> {\n    await this.pgPool.query("INSERT INTO users (id, name) VALUES ($1, $2)", [\n      id,\n      name,\n    ]);\n    console.log(`Saved to PostgreSQL (Relational): ${id}, ${name}`);\n  }\n\n  async saveNoSQLDocument(id: number, name: string): Promise<void> {\n    await this.mongoClient.connect();\n    const db = this.mongoClient.db("mydb");\n    await db\n      .collection("users")\n      .insertOne({ id, name, extra: { created: new Date() } });\n    console.log(`Saved to MongoDB (NoSQL Document): ${id}, ${name}`);\n  }\n\n  async saveNoSQLKeyValue(key: string, value: string): Promise<void> {\n    await this.redis.set(key, value);\n    console.log(`Saved to Redis (NoSQL Key-Value): ${key}, ${value}`);\n  }\n\n  async saveHybrid(id: number, name: string, jsonData: any): Promise<void> {\n    await this.pgPool.query(\n      "INSERT INTO users_json (id, name, data) VALUES ($1, $2, $3)",\n      [id, name, JSON.stringify(jsonData)]\n    );\n    console.log(\n      `Saved to PostgreSQL (Hybrid): ${id}, ${name}, ${JSON.stringify(\n        jsonData\n      )}`\n    );\n  }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Data Models Service Details"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Purpose"),": Demonstrates different data models using PostgreSQL (Relational), MongoDB (NoSQL Document), Redis (NoSQL Key-Value), and PostgreSQL with JSON (Hybrid)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Explanation"),": Initializes connections to each database type. ",(0,i.kt)("inlineCode",{parentName:"li"},"saveRelational")," stores structured data in PostgreSQL tables, ",(0,i.kt)("inlineCode",{parentName:"li"},"saveNoSQLDocument")," adds flexible documents to MongoDB, ",(0,i.kt)("inlineCode",{parentName:"li"},"saveNoSQLKeyValue")," uses Redis for key-value pairs, and ",(0,i.kt)("inlineCode",{parentName:"li"},"saveHybrid")," combines relational and JSON data in PostgreSQL, logging each action."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Data Models Details"),":",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Relational"),": PostgreSQL uses tables (e.g., ",(0,i.kt)("inlineCode",{parentName:"li"},"users")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"id"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"name")," columns)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"NoSQL"),": MongoDB stores documents (e.g., ",(0,i.kt)("inlineCode",{parentName:"li"},"{ id, name, extra }"),"), Redis uses key-value pairs."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Hybrid"),": PostgreSQL with JSON (e.g., ",(0,i.kt)("inlineCode",{parentName:"li"},"users_json")," with a ",(0,i.kt)("inlineCode",{parentName:"li"},"data")," JSONB column) blends structured and unstructured data.")))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"consistency-models"},"Consistency Models"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Consistency models"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ACID"),": Ensures reliable transactions (Atomicity, Consistency, Isolation, Durability) in SQL databases."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"BASE"),": Prioritizes availability and scalability (Basically Available, Soft state, Eventual consistency) in NoSQL."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Eventual consistency vs Strong consistency"),": Trade-off between immediate consistency (ACID) and delayed consistency (BASE).")),(0,i.kt)("h3",{id:"consistency-models-service"},"Consistency Models Service"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/consistency/consistency.service.ts (**Consistency models**)\nimport { Injectable } from "@nestjs/common";\nimport { Pool } from "pg";\nimport { Redis } from "ioredis";\n\n@Injectable()\nexport class ConsistencyService {\n  private pgPool: Pool;\n  private redis: Redis;\n\n  constructor() {\n    this.pgPool = new Pool({\n      user: "postgres",\n      host: "localhost",\n      database: "mydb",\n      password: "password",\n      port: 5432,\n    });\n    this.redis = new Redis({ host: "localhost", port: 6379 });\n  }\n\n  async acidTransaction(id: number, name: string): Promise<void> {\n    const client = await this.pgPool.connect();\n    try {\n      await client.query("BEGIN");\n      await client.query("INSERT INTO users (id, name) VALUES ($1, $2)", [\n        id,\n        name,\n      ]);\n      await client.query("COMMIT");\n      console.log(`ACID transaction completed: ${id}, ${name}`);\n    } catch (e) {\n      await client.query("ROLLBACK");\n      throw e;\n    } finally {\n      client.release();\n    }\n  }\n\n  async baseOperation(key: string, value: string): Promise<void> {\n    await this.redis.set(key, value);\n    console.log(`BASE operation (eventual consistency): ${key}, ${value}`);\n  }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Consistency Models Service Details"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Purpose"),": Demonstrates ACID transactions with PostgreSQL and BASE operations with Redis."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Explanation"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"acidTransaction")," uses a PostgreSQL transaction to ensure Atomicity, Consistency, Isolation, and Durability (ACID), while ",(0,i.kt)("inlineCode",{parentName:"li"},"baseOperation")," performs a simple Redis set operation, relying on eventual consistency (BASE), with logging for visibility."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Consistency Models Details"),":",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ACID"),": PostgreSQL ensures reliable writes with transactions (e.g., rollback on failure)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"BASE"),": Redis prioritizes availability and scalability, with data eventually consistent across nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Eventual vs Strong"),": ACID offers strong consistency (immediate); BASE offers eventual (delayed).")))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"scaling"},"Scaling"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Scaling"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Vertical scaling"),": Increases server capacity (e.g., more CPU/RAM)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Horizontal scaling"),": Adds more servers with techniques like:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Sharding"),": Splits data across nodes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Replication"),": Copies data for redundancy and read scaling."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Partitioning"),": Divides tables into smaller parts."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Load balancing"),": Distributes traffic across servers.")),(0,i.kt)("h3",{id:"scaling-service"},"Scaling Service"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/scaling/scaling.service.ts (**Scaling**)\nimport { Injectable } from "@nestjs/common";\nimport { Pool } from "pg";\nimport { MongoClient } from "mongodb";\n\n@Injectable()\nexport class ScalingService {\n  private pgPool: Pool;\n  private mongoClient: MongoClient;\n\n  constructor() {\n    this.pgPool = new Pool({\n      user: "postgres",\n      host: "localhost",\n      database: "mydb",\n      password: "password",\n      port: 5432,\n    });\n    this.mongoClient = new MongoClient("mongodb://localhost:27017");\n  }\n\n  async replicateData(id: number, name: string): Promise<void> {\n    const client = await this.pgPool.connect();\n    try {\n      await client.query("INSERT INTO users (id, name) VALUES ($1, $2)", [\n        id,\n        name,\n      ]);\n      console.log(\n        `Data replicated to PostgreSQL (assumed replica): ${id}, ${name}`\n      );\n    } finally {\n      client.release();\n    }\n  }\n\n  async shardData(id: number, name: string): Promise<void> {\n    await this.mongoClient.connect();\n    const db = this.mongoClient.db("mydb");\n    await db.collection("users").insertOne({ id, name });\n    console.log(`Data sharded to MongoDB (assumed shard): ${id}, ${name}`);\n  }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Scaling Service Details"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Purpose"),": Simulates replication and sharding with PostgreSQL and MongoDB."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Explanation"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"replicateData")," inserts into PostgreSQL (assuming replication setup externally), ",(0,i.kt)("inlineCode",{parentName:"li"},"shardData")," inserts into MongoDB (assuming sharding setup), logging actions to illustrate scaling techniques."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Scaling Details"),":",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Vertical Scaling"),": Not coded; implies upgrading server resources."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Horizontal Scaling"),": Replication (PostgreSQL) copies data; Sharding (MongoDB) splits data."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Load Balancing"),": Not coded; assumed with external tools like Nginx.")))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"performance-optimization"},"Performance Optimization"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Performance optimization"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Indexing"),": Speeds up queries with data structures (e.g., B-Tree)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Caching"),": Stores frequent data in memory (e.g., Redis)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Query optimization"),": Improves query efficiency (e.g., EXPLAIN in SQL)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Connection pooling"),": Reuses database connections for performance.")),(0,i.kt)("h3",{id:"performance-optimization-service"},"Performance Optimization Service"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/performance/performance.service.ts (**Performance optimization**)\nimport { Injectable } from "@nestjs/common";\nimport { Pool } from "pg";\nimport { Redis } from "ioredis";\n\n@Injectable()\nexport class PerformanceService {\n  private pgPool: Pool;\n  private redis: Redis;\n\n  constructor() {\n    this.pgPool = new Pool({\n      user: "postgres",\n      host: "localhost",\n      database: "mydb",\n      password: "password",\n      port: 5432,\n      max: 10, // Connection pooling\n    });\n    this.redis = new Redis({ host: "localhost", port: 6379 });\n  }\n\n  async indexedQuery(id: number): Promise<any> {\n    const result = await this.pgPool.query(\n      "SELECT * FROM users WHERE id = $1",\n      [id]\n    );\n    console.log(`Indexed query result: ${JSON.stringify(result.rows[0])}`);\n    return result.rows[0];\n  }\n\n  async cacheData(key: string, value: string): Promise<void> {\n    await this.redis.set(key, value, "EX", 3600);\n    console.log(`Cached data: ${key}, ${value}`);\n  }\n\n  async getCachedData(key: string): Promise<string | null> {\n    const value = await this.redis.get(key);\n    console.log(`Retrieved cached data: ${key}, ${value}`);\n    return value;\n  }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Performance Optimization Service Details"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Purpose"),": Demonstrates indexing, caching, and connection pooling for performance."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Explanation"),": Initializes a PostgreSQL pool with a max of 10 connections (pooling), ",(0,i.kt)("inlineCode",{parentName:"li"},"indexedQuery")," assumes an index on ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," for fast retrieval, ",(0,i.kt)("inlineCode",{parentName:"li"},"cacheData")," stores data in Redis with a 1-hour TTL, and ",(0,i.kt)("inlineCode",{parentName:"li"},"getCachedData")," retrieves it, logging actions to show optimization benefits."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Performance Optimization Details"),":",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Indexing"),": B-Tree on ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," (assumed) speeds up PostgreSQL queries."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Caching"),": Redis stores frequent data in memory."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Query Optimization"),": Not coded; ",(0,i.kt)("inlineCode",{parentName:"li"},"EXPLAIN")," would analyze query plans."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Connection Pooling"),": Reuses connections via ",(0,i.kt)("inlineCode",{parentName:"li"},"max: 10")," in Pool config.")))))}d.isMDXComponent=!0}}]);