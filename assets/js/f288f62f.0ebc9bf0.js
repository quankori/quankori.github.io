"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9518],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>v});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(t),m=o,v=u["".concat(l,".").concat(m)]||u[m]||d[m]||a;return t?r.createElement(v,s(s({ref:n},p),{},{components:t})):r.createElement(v,s({ref:n},p))}));function v(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,s=new Array(a);s[0]=m;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[u]="string"==typeof e?e:o,s[1]=i;for(var c=2;c<a;c++)s[c]=t[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},720:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var r=t(7462),o=(t(7294),t(3905));const a={title:"Nest.js Providers"},s=void 0,i={unversionedId:"programming/nodejs/nestjs-providers",id:"programming/nodejs/nestjs-providers",title:"Nest.js Providers",description:"Image",source:"@site/docs/programming/nodejs/nestjs-providers.md",sourceDirName:"programming/nodejs",slug:"/programming/nodejs/nestjs-providers",permalink:"/docs/programming/nodejs/nestjs-providers",draft:!1,tags:[],version:"current",frontMatter:{title:"Nest.js Providers"},sidebar:"programming",previous:{title:"Nest.js Dependency Injection (DI)",permalink:"/docs/programming/nodejs/nestjs-di"},next:{title:"Syntax",permalink:"/docs/programming/rust/syntax"}},l={},c=[{value:"Concept",id:"concept",level:2},{value:"Standart Providers",id:"standart-providers",level:2},{value:"Customer Providers",id:"customer-providers",level:2},{value:"Value providers: useValue",id:"value-providers-usevalue",level:3},{value:"Class providers: useClass",id:"class-providers-useclass",level:3},{value:"Factory providers: useFactory",id:"factory-providers-usefactory",level:3},{value:"Alias providers: useExisting",id:"alias-providers-useexisting",level:3},{value:"Non-service based providers",id:"non-service-based-providers",level:3},{value:"Provider scope",id:"provider-scope",level:2}],p={toc:c},u="wrapper";function d(e){let{components:n,...t}=e;return(0,o.kt)(u,(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/quankori/quankori.github.io/master/src/images/nestjs/1.png",alt:"Image"})),(0,o.kt)("h2",{id:"concept"},"Concept"),(0,o.kt)("p",null,"In NestJS, providers are objects responsible for providing services, functions, or objects to other parts of the application such as controllers, modules, and injectables. Providers are at the core of the dependency injection system in NestJS, allowing other parts of the application to request and use services without needing to know exactly how they are created."),(0,o.kt)("h2",{id:"standart-providers"},"Standart Providers"),(0,o.kt)("p",null,"In addition to using the @Injectable() decorator, you can also create custom providers using an object literal syntax."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { Injectable } from "@nestjs/common";\n\n@Injectable()\nexport class CatsService {\n  findAll() {\n    return ["Cat 1", "Cat 2"];\n  }\n}\n')),(0,o.kt)("h2",{id:"customer-providers"},"Customer Providers"),(0,o.kt)("h3",{id:"value-providers-usevalue"},"Value providers: useValue"),(0,o.kt)("p",null,"Use useValue to provide a fixed value for a provider."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const catsServiceProvider = {\n  provide: "CatsService",\n  useValue: {\n    findAll: () => ["Cat 1", "Cat 2"],\n  },\n};\n')),(0,o.kt)("h3",{id:"class-providers-useclass"},"Class providers: useClass"),(0,o.kt)("p",null,"Use useValue to provide a class to create instance for provider."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const catsServiceProvider = {\n  provide: "CatsService",\n  useClass: CatsService,\n};\n')),(0,o.kt)("h3",{id:"factory-providers-usefactory"},"Factory providers: useFactory"),(0,o.kt)("p",null,"Factory providers allow you to use a function to create an instance of the provider. This enables you to customize the initialization of the provider based on specific logic or configuration."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { Module } from "@nestjs/common";\nimport { Connection, DatabaseService } from "./database.service";\n\n@Module({\n  providers: [\n    DatabaseService,\n    {\n      provide: "CONNECTION",\n      useFactory: (connection: Connection) => {\n        return new DatabaseService(connection);\n      },\n      inject: [Connection],\n    },\n  ],\n  exports: ["CONNECTION", DatabaseService],\n})\nexport class DatabaseModule {}\n')),(0,o.kt)("p",null,"In this example, ",(0,o.kt)("inlineCode",{parentName:"p"},"DatabaseService")," is a provider, and ",(0,o.kt)("inlineCode",{parentName:"p"},"CONNECTION")," is created by the factory function. The factory function can access and use the Connection to create an instance of DatabaseService."),(0,o.kt)("p",null,"In this example, ",(0,o.kt)("inlineCode",{parentName:"p"},"Connection")," is another class/provider that is injected into the factory function through ",(0,o.kt)("inlineCode",{parentName:"p"},"inject: [Connection]"),". When NestJS needs to create an instance of the ",(0,o.kt)("inlineCode",{parentName:"p"},"CONNECTION")," provider, it will automatically inject an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"Connection")," into the factory function."),(0,o.kt)("h3",{id:"alias-providers-useexisting"},"Alias providers: useExisting"),(0,o.kt)("p",null,"Alias providers allow you to create an alternative name for an existing provider. This is useful when you want to use a shorter name or change the name of a provider without affecting its usage in other modules."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { Module } from "@nestjs/common";\nimport { ExistingService } from "./existing.service";\n\n@Module({\n  providers: [ExistingService],\n  exports: [ExistingService],\n})\nexport class AppModule {}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { Module } from "@nestjs/common";\nimport { AliasService } from "./alias.service";\n\n@Module({\n  providers: [\n    {\n      provide: "AliasService",\n      useExisting: ExistingService,\n    },\n  ],\n})\nexport class CatsModule {}\n')),(0,o.kt)("p",null,"In this example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"AliasService")," provider is essentially ",(0,o.kt)("inlineCode",{parentName:"p"},"ExistingService")," but with a different name for use in the ",(0,o.kt)("inlineCode",{parentName:"p"},"CatsModule"),"."),(0,o.kt)("h3",{id:"non-service-based-providers"},"Non-service based providers"),(0,o.kt)("p",null,"Non-service based providers can be used to define values that do not require the instantiation of a class provider. They are often used to provide simple values like strings, numbers, or constants."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { Module } from "@nestjs/common";\n\n@Module({\n  providers: [\n    {\n      provide: "API_KEY",\n      useValue: "your-api-key",\n    },\n    {\n      provide: "MAX_RETRIES",\n      useValue: 5,\n    },\n  ],\n})\nexport class AppModule {}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { Controller, Get, Inject } from "@nestjs/common";\n\n@Controller("cats")\nexport class CatsController {\n  constructor(\n    @Inject("API_KEY") private apiKey: string,\n    @Inject("MAX_RETRIES") private maxRetries: number\n  ) {}\n\n  @Get()\n  getCats() {\n    console.log("API Key:", this.apiKey);\n    console.log("Max Retries:", this.maxRetries);\n    // Your controller logic here\n  }\n}\n')),(0,o.kt)("h2",{id:"provider-scope"},"Provider scope"),(0,o.kt)("p",null,"Each provider has its own usage scope, including ",(0,o.kt)("inlineCode",{parentName:"p"},"SINGLETON"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"TRANSIENT"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"REQUEST"),". For example, when a request is sent to the ",(0,o.kt)("inlineCode",{parentName:"p"},"SINGLETON")," scope, it reuses the already-used instance, while ",(0,o.kt)("inlineCode",{parentName:"p"},"TRANSIENT")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"REQUEST")," create new instances."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Singleton")," (Default): Each provider is created only once and shared across all modules and components in the application. This ensures that a single instance of the provider is used for all requests in the application."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { Injectable, Scope } from "@nestjs/common";\n\n@Injectable({ scope: Scope.DEFAULT })\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Transient"),": Each request creates a separate instance of the provider. This ensures that each request has an independent instance of the provider without affecting other requests."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { Injectable, Scope } from "@nestjs/common";\n\n@Injectable({ scope: Scope.TRANSIENT })\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Request"),": This mechanism creates a separate instance of the provider for each request, but unlike transient, instances of request-scoped providers are shared throughout the processing of a single request. Other requests will have different instances."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Injectable, Scope } from '@nestjs/common';\n\n@Injectable({ scope: Scope.REQUEST })\n")))}d.isMDXComponent=!0}}]);