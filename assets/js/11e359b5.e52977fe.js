"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4212],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>d});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=a.createContext({}),p=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(o.Provider,{value:n},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(t),g=r,d=m["".concat(o,".").concat(g)]||m[g]||u[g]||i;return t?a.createElement(d,l(l({ref:n},c),{},{components:t})):a.createElement(d,l({ref:n},c))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=g;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[m]="string"==typeof e?e:r,l[1]=s;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},7891:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const i={title:"Slices & Array"},l=void 0,s={unversionedId:"programming/go/slices-array",id:"programming/go/slices-array",title:"Slices & Array",description:"Slices and Arrays are two data structures in Go related to storing elements of the same data type. However, they have significant differences in terms of the ability to change size and how they operate.",source:"@site/docs/programming/go/slices-array.md",sourceDirName:"programming/go",slug:"/programming/go/slices-array",permalink:"/docs/programming/go/slices-array",draft:!1,tags:[],version:"current",frontMatter:{title:"Slices & Array"},sidebar:"programming",previous:{title:"Pointers",permalink:"/docs/programming/go/pointers"},next:{title:"Testing",permalink:"/docs/programming/go/testing"}},o={},p=[{value:"Slices",id:"slices",level:2},{value:"Length",id:"length",level:3},{value:"Capacity",id:"capacity",level:3},{value:"Creating Slices",id:"creating-slices",level:3},{value:"Reslicing",id:"reslicing",level:3},{value:"Appending Elements",id:"appending-elements",level:3},{value:"Example Code",id:"example-code",level:3},{value:"Output",id:"output",level:3},{value:"Arrays",id:"arrays",level:2},{value:"Summary",id:"summary",level:2}],c={toc:p},m="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(m,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Slices and Arrays are two data structures in Go related to storing elements of the same data type. However, they have significant differences in terms of the ability to change size and how they operate."),(0,r.kt)("h2",{id:"slices"},"Slices"),(0,r.kt)("p",null,"Slices in Go are a flexible data structure that allows you to work with dynamic arrays. A slice is a flexible 'view' of the original array, allowing you to change the size of the array without creating a new one. Slices make managing and accessing arrays easier."),(0,r.kt)("p",null,"Here is an easy-to-understand example of how to use slices:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\nfunc main() {\n    numbers := []int{1, 2, 3, 4, 5}\n    fmt.Println("Original slice:", numbers)\n\n    numbers[0] = 10\n\n    numbers = append(numbers, 6)\n\n    subset := numbers[1:4]\n\n    fmt.Println("Modified slice:", numbers)\n    fmt.Println("Subset slice:", subset)\n}\n\n// Original slice: [1 2 3 4 5]\n// Modified slice: [10 2 3 4 5 6]\n// Subset slice: [2 3 4]\n')),(0,r.kt)("h3",{id:"length"},"Length"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The length of a slice is the number of elements it contains.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Characteristics"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The length is dynamic and can change when elements are added or removed."),(0,r.kt)("li",{parentName:"ul"},"The length of a slice can be obtained using the built-in ",(0,r.kt)("inlineCode",{parentName:"li"},"len")," function.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"s := []int{1, 2, 3, 4, 5}\nfmt.Println(len(s))  // Output: 5\n")),(0,r.kt)("h3",{id:"capacity"},"Capacity"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The capacity of a slice is the number of elements it can hold before needing to allocate more memory.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Characteristics"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The capacity is always greater than or equal to the length."),(0,r.kt)("li",{parentName:"ul"},"The capacity of a slice can be obtained using the built-in ",(0,r.kt)("inlineCode",{parentName:"li"},"cap")," function."),(0,r.kt)("li",{parentName:"ul"},"When a slice grows beyond its capacity, Go allocates a new underlying array with more capacity.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"s := []int{1, 2, 3, 4, 5}\nfmt.Println(cap(s))  // Output: 5\n")),(0,r.kt)("h3",{id:"creating-slices"},"Creating Slices"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"From an Array"),":\nWhen a slice is created from an array, the length is the number of elements in the slice, and the capacity is the number of elements from the start of the slice to the end of the array."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"arr := [5]int{1, 2, 3, 4, 5}\ns := arr[1:4]  // Slice from index 1 to 3\nfmt.Println(len(s))  // Output: 3\nfmt.Println(cap(s))  // Output: 4\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Using ",(0,r.kt)("inlineCode",{parentName:"strong"},"make")),":\nWhen creating a slice using the ",(0,r.kt)("inlineCode",{parentName:"p"},"make")," function, you can specify the length and capacity."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"s := make([]int, 3, 5)  // Slice with length 3 and capacity 5\nfmt.Println(len(s))  // Output: 3\nfmt.Println(cap(s))  // Output: 5\n")),(0,r.kt)("h3",{id:"reslicing"},"Reslicing"),(0,r.kt)("p",null,"You can create a new slice from an existing slice, which can change the length but not the capacity."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"s := []int{1, 2, 3, 4, 5}\ns1 := s[:3]\nfmt.Println(len(s1))  // Output: 3\nfmt.Println(cap(s1))  // Output: 5\n\ns2 := s[2:]\nfmt.Println(len(s2))  // Output: 3\nfmt.Println(cap(s2))  // Output: 3\n")),(0,r.kt)("h3",{id:"appending-elements"},"Appending Elements"),(0,r.kt)("p",null,"When you append elements to a slice, if the length exceeds the capacity, Go allocates a new underlying array with a larger capacity."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"s := []int{1, 2, 3}\nfmt.Println(len(s))  // Output: 3\nfmt.Println(cap(s))  // Output: 3\n\ns = append(s, 4, 5)\nfmt.Println(len(s))  // Output: 5\nfmt.Println(cap(s))  // Output: 6 (or more, depending on Go's allocation strategy)\n")),(0,r.kt)("h3",{id:"example-code"},"Example Code"),(0,r.kt)("p",null,"Here is a complete example demonstrating length and capacity in Go slices:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n)\n\nfunc main() {\n    // Creating a slice from an array\n    arr := [5]int{1, 2, 3, 4, 5}\n    s1 := arr[1:4]\n    fmt.Printf("s1: len=%d cap=%d %v\\n", len(s1), cap(s1), s1)\n\n    // Creating a slice using make\n    s2 := make([]int, 3, 5)\n    fmt.Printf("s2: len=%d cap=%d %v\\n", len(s2), cap(s2), s2)\n\n    // Reslicing\n    s3 := s1[:2]\n    fmt.Printf("s3: len=%d cap=%d %v\\n", len(s3), cap(s3), s3)\n\n    // Appending elements\n    s4 := []int{1, 2, 3}\n    fmt.Printf("s4: len=%d cap=%d %v\\n", len(s4), cap(s4), s4)\n    s4 = append(s4, 4, 5)\n    fmt.Printf("s4 after append: len=%d cap=%d %v\\n", len(s4), cap(s4), s4)\n}\n')),(0,r.kt)("h3",{id:"output"},"Output"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-plaintext"},"s1: len=3 cap=4 [2 3 4]\ns2: len=3 cap=5 [0 0 0]\ns3: len=2 cap=4 [2 3]\ns4: len=3 cap=3 [1 2 3]\ns4 after append: len=5 cap=6 [1 2 3 4 5]\n")),(0,r.kt)("h2",{id:"arrays"},"Arrays"),(0,r.kt)("p",null,"An array is a fundamental data structure in Go used to store elements of the same data type. The size of an array is determined when it is declared and cannot be changed afterward. This imposes a limitation on the ability to change the size of the array."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"primes := [6]int{2, 3, 5, 7, 11, 13}\n")),(0,r.kt)("p",null,"However, arrays in Go have limitations on the ability to change their size and are not as flexible as slices. Therefore, in most situations, programmers often prefer to use slices rather than arrays to manage data."),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Length (",(0,r.kt)("inlineCode",{parentName:"strong"},"len"),")"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Represents the number of elements in the slice."),(0,r.kt)("li",{parentName:"ul"},"Changes as elements are added or removed."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Capacity (",(0,r.kt)("inlineCode",{parentName:"strong"},"cap"),")"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Represents the maximum number of elements the slice can hold before needing to allocate more memory."),(0,r.kt)("li",{parentName:"ul"},"Changes when the underlying array is resized.")))))}u.isMDXComponent=!0}}]);