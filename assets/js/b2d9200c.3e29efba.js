"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6800],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},y=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),u=s(n),y=r,k=u["".concat(l,".").concat(y)]||u[y]||m[y]||i;return n?a.createElement(k,o(o({ref:t},c),{},{components:n})):a.createElement(k,o({ref:t},c))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=y;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[u]="string"==typeof e?e:r,o[1]=p;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}y.displayName="MDXCreateElement"},6548:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>p,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const i={title:"Types and Interfaces Typescript"},o=void 0,p={unversionedId:"programming/nodejs/types-interfaces",id:"programming/nodejs/types-interfaces",title:"Types and Interfaces Typescript",description:"Types & Interfaces",source:"@site/docs/programming/nodejs/types-interfaces.md",sourceDirName:"programming/nodejs",slug:"/programming/nodejs/types-interfaces",permalink:"/docs/programming/nodejs/types-interfaces",draft:!1,tags:[],version:"current",frontMatter:{title:"Types and Interfaces Typescript"},sidebar:"programming",previous:{title:"Scopes",permalink:"/docs/programming/nodejs/scope"}},l={},s=[{value:"Types &amp; Interfaces",id:"types--interfaces",level:2},{value:"Types: <code>any</code>, <code>unknown</code>, and Intersection Types",id:"types-any-unknown-and-intersection-types",level:2},{value:"<code>any</code> Type",id:"any-type",level:3},{value:"<code>unknown</code> Type",id:"unknown-type",level:3},{value:"Intersection Types",id:"intersection-types",level:3},{value:"Practical Example",id:"practical-example",level:3},{value:"Summary",id:"summary",level:3}],c={toc:s},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"types--interfaces"},"Types & Interfaces"),(0,r.kt)("p",null,"In TypeScript, both data types (type) and interfaces (interface) are powerful ways to define the shape of an object or data structure. However, there are differences in capabilities, usage, and when to choose one over the other."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type User = {\n  id: string;\n  name: string;\n} | null;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface User {\n  id: string;\n  name: string;\n}\n\ninterface Admin extends User {\n  permissions: string[];\n}\n")),(0,r.kt)("p",null,"Comparison and Use Cases:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"For object shapes"),": Both ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"interface")," can be used, but if you expect consumers of your code (like other developers) to extend, modify, or implement object shapes, ",(0,r.kt)("inlineCode",{parentName:"p"},"interface")," is often preferred due to its extensibility."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Extending"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"interface")," supports inheritance from other interface using the ",(0,r.kt)("inlineCode",{parentName:"p"},"extends")," keyword. While you can achieve a similar effect using intersection types with type, ",(0,r.kt)("inlineCode",{parentName:"p"},"interface")," provides a more reasonable approach to object-oriented programming (OOP) modeling."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Union Types"),": If you need types (e.g., string | number), ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," is the only choice."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Declaration Merging"),": Only ",(0,r.kt)("inlineCode",{parentName:"p"},"interface")," supports declaration merging. This is useful when you want to gradually or incrementally add to the shape of an object across multiple files or locations in your source code."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Implementing in Classes"),": If you are defining a structure that a class will adhere to, use ",(0,r.kt)("inlineCode",{parentName:"p"},"interface"),". This allows you to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"implements")," keyword with classes."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Performance"),": During compilation, ",(0,r.kt)("inlineCode",{parentName:"p"},"interface")," is slightly faster because it requires less computation compared to ",(0,r.kt)("inlineCode",{parentName:"p"},"type"),". However, this difference is often negligible for most projects."),(0,r.kt)("p",null,"In summary, while there is some overlap in many of their capabilities, the choice between ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"interface")," depends on the specific use case. As a general rule, for object shapes, especially shapes that may be extended or implemented, interface is often preferred. For ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," definitions, unions, intersections, or mapped types, type is the top choice."),(0,r.kt)("h2",{id:"types-any-unknown-and-intersection-types"},"Types: ",(0,r.kt)("inlineCode",{parentName:"h2"},"any"),", ",(0,r.kt)("inlineCode",{parentName:"h2"},"unknown"),", and Intersection Types"),(0,r.kt)("p",null,"TypeScript is a statically typed superset of JavaScript that adds static types to the language. Understanding the differences between ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"unknown"),", as well as how intersection types work, is crucial for writing robust and type-safe TypeScript code."),(0,r.kt)("h3",{id:"any-type"},(0,r.kt)("inlineCode",{parentName:"h3"},"any")," Type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"any")," type in TypeScript is a type that can represent any JavaScript value. It effectively disables type checking for the variable it is assigned to.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Characteristics"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Opt-Out of Type Checking"),": Using ",(0,r.kt)("inlineCode",{parentName:"li"},"any")," means that the compiler will not perform type checking on the variable."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Implicit Any"),": If a variable is declared without a type and without being initialized, it implicitly has the ",(0,r.kt)("inlineCode",{parentName:"li"},"any")," type.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pros"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Useful when you are migrating JavaScript code to TypeScript."),(0,r.kt)("li",{parentName:"ul"},"Helps when working with third-party libraries that do not have type definitions.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Cons"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Reduces type safety because it disables the benefits of TypeScript\u2019s type checking."),(0,r.kt)("li",{parentName:"ul"},"Can lead to runtime errors if used excessively or improperly.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'let value: any;\nvalue = 5; // OK\nvalue = "hello"; // OK\nvalue = true; // OK\nvalue.foo.bar(); // OK at compile-time, but may cause runtime errors\n')),(0,r.kt)("h3",{id:"unknown-type"},(0,r.kt)("inlineCode",{parentName:"h3"},"unknown")," Type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"unknown")," type in TypeScript is a type-safe counterpart to ",(0,r.kt)("inlineCode",{parentName:"li"},"any"),". It can hold any value but requires type checking before performing operations on the variable.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Characteristics"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Type-Safe ",(0,r.kt)("inlineCode",{parentName:"strong"},"any")),": You must perform some form of type assertion or checking before using it."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Type Narrowing"),": Use type assertions or type guards to narrow down the type.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pros"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Encourages type safety by requiring explicit type checks."),(0,r.kt)("li",{parentName:"ul"},"Prevents many of the pitfalls associated with ",(0,r.kt)("inlineCode",{parentName:"li"},"any"),".")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Cons"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Requires more boilerplate code for type assertions and checks.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'let value: unknown;\nvalue = 5; // OK\nvalue = "hello"; // OK\n\n// Type assertion\nlet str: string = value as string;\n\n// Type guard\nif (typeof value === "string") {\n  console.log(value.toUpperCase()); // OK\n} else {\n  console.log("Value is not a string");\n}\n\n// This would cause a compile-time error:\n// value.foo.bar();\n')),(0,r.kt)("h3",{id:"intersection-types"},"Intersection Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Intersection types in TypeScript allow you to combine multiple types into one. An intersection type represents an object that includes all the properties and methods of the intersected types.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Characteristics"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Combining Types"),": Combines properties of multiple types into a single type."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Type Safety"),": Ensures that the resulting type has all the properties of the combined types.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pros"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Useful for creating complex types by combining simpler ones."),(0,r.kt)("li",{parentName:"ul"},"Helps in creating types that are more descriptive and specific.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Cons"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Can lead to complex types that are harder to read and understand.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'interface Person {\n  name: string;\n}\n\ninterface Employee {\n  employeeId: number;\n}\n\ntype EmployeePerson = Person & Employee;\n\nconst employee: EmployeePerson = {\n  name: "John Doe",\n  employeeId: 12345,\n};\n\n// Using the properties from both types\nconsole.log(employee.name); // John Doe\nconsole.log(employee.employeeId); // 12345\n')),(0,r.kt)("h3",{id:"practical-example"},"Practical Example"),(0,r.kt)("p",null,"Let's combine ",(0,r.kt)("inlineCode",{parentName:"p"},"unknown")," and intersection types in a practical scenario:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'function logDetails(value: unknown): void {\n  if (typeof value === "string") {\n    console.log(`String: ${value.toUpperCase()}`);\n  } else if (typeof value === "number") {\n    console.log(`Number: ${value.toFixed(2)}`);\n  } else if (typeof value === "object" && value !== null) {\n    console.log("Object: ", value);\n  } else {\n    console.log("Unknown type");\n  }\n}\n\ninterface Name {\n  name: string;\n}\n\ninterface Age {\n  age: number;\n}\n\ntype PersonWithAge = Name & Age;\n\nconst person: PersonWithAge = { name: "Alice", age: 30 };\nlogDetails(person); // Object:  { name: \'Alice\', age: 30 }\n')),(0,r.kt)("h3",{id:"summary"},"Summary"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"any")," Type"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Definition"),": Represents any value without type checking."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Usage"),": Useful for migrating JavaScript code and dealing with third-party libraries."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Pros"),": Flexibility."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Cons"),": Lack of type safety, potential runtime errors."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"unknown")," Type"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Definition"),": Represents any value with type safety."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Usage"),": Requires type checking or assertions before use."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Pros"),": Type safety."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Cons"),": Requires more code for type checks."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Intersection Types"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Definition"),": Combines multiple types into one."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Usage"),": Creating complex types from simpler ones."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Pros"),": Descriptive, specific types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Cons"),": Can become complex and harder to read.")))))}m.isMDXComponent=!0}}]);