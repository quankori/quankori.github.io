"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[675],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>d});var n=r(7294);function s(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){s(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,s=function(e,t){if(null==e)return{};var r,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(s[r]=e[r]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(s[r]=e[r])}return s}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},v=n.forwardRef((function(e,t){var r=e.components,s=e.mdxType,i=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=l(r),v=s,d=u["".concat(c,".").concat(v)]||u[v]||m[v]||i;return r?n.createElement(d,a(a({ref:t},p),{},{components:r})):n.createElement(d,a({ref:t},p))}));function d(e,t){var r=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=r.length,a=new Array(i);a[0]=v;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[u]="string"==typeof e?e:s,a[1]=o;for(var l=2;l<i;l++)a[l]=r[l];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}v.displayName="MDXCreateElement"},760:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var n=r(7462),s=(r(7294),r(3905));const i={title:"Microservices Architecture"},a=void 0,o={unversionedId:"cheatsheet/system-design/microservices",id:"cheatsheet/system-design/microservices",title:"Microservices Architecture",description:"Communication Patterns",source:"@site/docs/cheatsheet/system-design/microservices.md",sourceDirName:"cheatsheet/system-design",slug:"/cheatsheet/system-design/microservices",permalink:"/docs/cheatsheet/system-design/microservices",draft:!1,tags:[],version:"current",frontMatter:{title:"Microservices Architecture"},sidebar:"cheatsheet",previous:{title:"Event-Driven Architecture",permalink:"/docs/cheatsheet/system-design/event-driven"},next:{title:"Serverless Architecture",permalink:"/docs/cheatsheet/system-design/serverless"}},c={},l=[{value:"Communication Patterns",id:"communication-patterns",level:2},{value:"Microservice Resiliency Patterns",id:"microservice-resiliency-patterns",level:2},{value:"Key Differences",id:"key-differences",level:2}],p={toc:l},u="wrapper";function m(e){let{components:t,...r}=e;return(0,s.kt)(u,(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"communication-patterns"},"Communication Patterns"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Overview"),": Communication Patterns in Microservices define how services interact, either synchronously (immediate response) or asynchronously (event-based), enabling loose coupling and scalability."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Synchronous"),": Direct, blocking calls between services (e.g., HTTP/REST)."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Asynchronous"),": Non-blocking, event-driven communication (e.g., Kafka, RabbitMQ)."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Source Tree"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"src/\n\u251c\u2500\u2500 sync/\n\u2502   \u2514\u2500\u2500 sync.service.ts\n\u251c\u2500\u2500 async/\n\u2502   \u2514\u2500\u2500 kafka.service.ts\n\u2514\u2500\u2500 app.module.ts\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"NestJS Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/sync/sync.service.ts (**Synchronous**)\nimport { Injectable, HttpService } from "@nestjs/common";\nimport { HttpModule } from "@nestjs/axios";\n\n@Injectable()\nexport class SyncService {\n  constructor(private httpService: HttpService) {}\n\n  async callSyncService(userId: number) {\n    const response = await this.httpService\n      .get(`http://localhost:3001/users/${userId}`)\n      .toPromise();\n    return response.data; // Synchronous REST call\n  }\n}\n\n// src/async/kafka.service.ts (**Asynchronous**)\nimport { Injectable, OnModuleInit } from "@nestjs/common";\nimport { Kafka, Producer } from "kafkajs";\n\n@Injectable()\nexport class KafkaService implements OnModuleInit {\n  private kafka = new Kafka({\n    clientId: "my-app",\n    brokers: ["localhost:9092"],\n  });\n  private producer: Producer;\n\n  constructor() {\n    this.producer = this.kafka.producer();\n  }\n\n  async onModuleInit() {\n    await this.producer.connect();\n  }\n\n  async emitUserEvent(userId: number, name: string) {\n    await this.producer.send({\n      topic: "user-events",\n      messages: [{ value: JSON.stringify({ userId, name }) }],\n    }); // Asynchronous Kafka event\n  }\n}\n\n// src/app.module.ts\nimport { Module } from "@nestjs/common";\nimport { HttpModule } from "@nestjs/axios";\nimport { SyncService } from "./sync/sync.service";\nimport { KafkaService } from "./async/kafka.service";\n\n@Module({\n  imports: [HttpModule],\n  providers: [SyncService, KafkaService],\n})\nexport class AppModule {}\n\n// src/main.ts\nimport { NestFactory } from "@nestjs/core";\nimport { AppModule } from "./app.module";\nimport { SyncService } from "./sync/sync.service";\nimport { KafkaService } from "./async/kafka.service";\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  const syncService = app.get(SyncService);\n  const kafkaService = app.get(KafkaService);\n\n  // Synchronous call\n  console.log(await syncService.callSyncService(1));\n\n  // Asynchronous event\n  await kafkaService.emitUserEvent(1, "John");\n\n  await app.listen(3000);\n}\nbootstrap();\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Note"),": Assumes a second service at ",(0,s.kt)("inlineCode",{parentName:"p"},"localhost:3001")," for sync calls and Kafka at ",(0,s.kt)("inlineCode",{parentName:"p"},"localhost:9092"),". Install ",(0,s.kt)("inlineCode",{parentName:"p"},"kafkajs")," via ",(0,s.kt)("inlineCode",{parentName:"p"},"npm install kafkajs"),"."),(0,s.kt)("hr",null),(0,s.kt)("h2",{id:"microservice-resiliency-patterns"},"Microservice Resiliency Patterns"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Overview"),": Microservice Resiliency Patterns ensure services remain robust and available despite failures, using strategies like circuit breaking, retries, and load management to handle distributed system challenges."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Circuit breaker pattern"),": Stops requests to a failing service to prevent overload."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Retry pattern"),": Reattempts failed operations with delays."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Timeout pattern"),": Limits wait time for responses to avoid hanging."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Bulkhead pattern"),": Isolates failures to prevent cascading effects."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Fallback pattern"),": Provides default responses when services fail."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Load shedding pattern"),": Drops excess requests to maintain stability."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Service aggregator pattern"),": Combines data from multiple services."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Service discovery pattern"),": Dynamically locates services (e.g., Consul, Eureka)."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Gateway routing pattern"),": Routes requests through a central gateway."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Gateway offloading pattern"),": Offloads tasks like authentication to a gateway."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Source Tree"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"src/\n\u251c\u2500\u2500 resiliency/\n\u2502   \u251c\u2500\u2500 circuit-breaker.service.ts\n\u2502   \u251c\u2500\u2500 retry.service.ts\n\u2502   \u251c\u2500\u2500 timeout.service.ts\n\u2502   \u251c\u2500\u2500 bulkhead.service.ts\n\u2502   \u251c\u2500\u2500 fallback.service.ts\n\u2502   \u251c\u2500\u2500 load-shedding.service.ts\n\u2502   \u251c\u2500\u2500 aggregator.service.ts\n\u2502   \u251c\u2500\u2500 discovery.service.ts\n\u2502   \u2514\u2500\u2500 gateway.service.ts\n\u2514\u2500\u2500 app.module.ts\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"NestJS Example"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},'// src/resiliency/circuit-breaker.service.ts (**Circuit breaker pattern**)\nimport { Injectable } from "@nestjs/common";\nimport { CircuitBreaker } from "opossum";\nimport { HttpService } from "@nestjs/axios";\n\n@Injectable()\nexport class CircuitBreakerService {\n  private breaker: CircuitBreaker;\n\n  constructor(private httpService: HttpService) {\n    this.breaker = new CircuitBreaker(\n      async () => {\n        return this.httpService\n          .get("http://localhost:3001/users/1")\n          .toPromise();\n      },\n      { timeout: 1000 }\n    );\n  }\n\n  async getUser() {\n    return this.breaker.fire().catch(() => "Service unavailable");\n  }\n}\n\n// src/resiliency/retry.service.ts (**Retry pattern**)\nimport { Injectable } from "@nestjs/common";\nimport { HttpService } from "@nestjs/axios";\n\n@Injectable()\nexport class RetryService {\n  constructor(private httpService: HttpService) {}\n\n  async getUserWithRetry() {\n    for (let i = 0; i < 3; i++) {\n      try {\n        return await this.httpService\n          .get("http://localhost:3001/users/1")\n          .toPromise();\n      } catch {\n        await new Promise((resolve) => setTimeout(resolve, 1000)); // Retry after 1s\n      }\n    }\n    throw new Error("All retries failed");\n  }\n}\n\n// src/resiliency/timeout.service.ts (**Timeout pattern**)\nimport { Injectable } from "@nestjs/common";\nimport { HttpService } from "@nestjs/axios";\n\n@Injectable()\nexport class TimeoutService {\n  constructor(private httpService: HttpService) {}\n\n  async getUserWithTimeout() {\n    return Promise.race([\n      this.httpService.get("http://localhost:3001/users/1").toPromise(),\n      new Promise((_, reject) => setTimeout(() => reject("Timeout"), 2000)),\n    ]);\n  }\n}\n\n// src/resiliency/bulkhead.service.ts (**Bulkhead pattern**)\nimport { Injectable } from "@nestjs/common";\nimport { HttpService } from "@nestjs/axios";\n\n@Injectable()\nexport class BulkheadService {\n  private queue: Promise<any>[] = [];\n\n  constructor(private httpService: HttpService) {}\n\n  async getUserWithBulkhead() {\n    if (this.queue.length < 5) {\n      // Limit to 5 concurrent requests\n      const request = this.httpService\n        .get("http://localhost:3001/users/1")\n        .toPromise();\n      this.queue.push(request);\n      const result = await request;\n      this.queue = this.queue.filter((q) => q !== request);\n      return result;\n    }\n    throw new Error("Bulkhead limit reached");\n  }\n}\n\n// src/resiliency/fallback.service.ts (**Fallback pattern**)\nimport { Injectable } from "@nestjs/common";\nimport { HttpService } from "@nestjs/axios";\n\n@Injectable()\nexport class FallbackService {\n  constructor(private httpService: HttpService) {}\n\n  async getUserWithFallback() {\n    try {\n      return await this.httpService\n        .get("http://localhost:3001/users/1")\n        .toPromise();\n    } catch {\n      return { id: 1, name: "Default User" }; // Fallback response\n    }\n  }\n}\n\n// src/resiliency/load-shedding.service.ts (**Load shedding pattern**)\nimport { Injectable } from "@nestjs/common";\nimport { HttpService } from "@nestjs/axios";\n\n@Injectable()\nexport class LoadSheddingService {\n  private load = 0;\n\n  constructor(private httpService: HttpService) {}\n\n  async getUserWithLoadShedding() {\n    if (this.load < 10) {\n      // Shed load if > 10 requests\n      this.load++;\n      const result = await this.httpService\n        .get("http://localhost:3001/users/1")\n        .toPromise();\n      this.load--;\n      return result;\n    }\n    throw new Error("Load shed");\n  }\n}\n\n// src/resiliency/aggregator.service.ts (**Service aggregator pattern**)\nimport { Injectable } from "@nestjs/common";\nimport { HttpService } from "@nestjs/axios";\n\n@Injectable()\nexport class AggregatorService {\n  constructor(private httpService: HttpService) {}\n\n  async aggregateUserData(userId: number) {\n    const user = await this.httpService\n      .get(`http://localhost:3001/users/${userId}`)\n      .toPromise();\n    const orders = await this.httpService\n      .get(`http://localhost:3002/orders/${userId}`)\n      .toPromise();\n    return { user: user.data, orders: orders.data };\n  }\n}\n\n// src/app.module.ts\nimport { Module } from "@nestjs/common";\nimport { HttpModule } from "@nestjs/axios";\nimport { CircuitBreakerService } from "./resiliency/circuit-breaker.service";\nimport { RetryService } from "./resiliency/retry.service";\nimport { TimeoutService } from "./resiliency/timeout.service";\nimport { BulkheadService } from "./resiliency/bulkhead.service";\nimport { FallbackService } from "./resiliency/fallback.service";\nimport { LoadSheddingService } from "./resiliency/load-shedding.service";\nimport { AggregatorService } from "./resiliency/aggregator.service";\n\n@Module({\n  imports: [HttpModule],\n  providers: [\n    CircuitBreakerService,\n    RetryService,\n    TimeoutService,\n    BulkheadService,\n    FallbackService,\n    LoadSheddingService,\n    AggregatorService,\n  ],\n})\nexport class AppModule {}\n\n// src/main.ts\nimport { NestFactory } from "@nestjs/core";\nimport { AppModule } from "./app.module";\nimport { CircuitBreakerService } from "./resiliency/circuit-breaker.service";\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  const circuitBreaker = app.get(CircuitBreakerService);\n\n  console.log(await circuitBreaker.getUser()); // Example: Circuit Breaker\n\n  await app.listen(3000);\n}\nbootstrap();\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Notes"),":"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Install ",(0,s.kt)("inlineCode",{parentName:"li"},"opossum")," for Circuit Breaker: ",(0,s.kt)("inlineCode",{parentName:"li"},"npm install opossum"),"."),(0,s.kt)("li",{parentName:"ul"},"Assumes external services at ",(0,s.kt)("inlineCode",{parentName:"li"},"localhost:3001")," and ",(0,s.kt)("inlineCode",{parentName:"li"},"3002")," for aggregation.")),(0,s.kt)("hr",null),(0,s.kt)("h2",{id:"key-differences"},"Key Differences"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Communication Patterns"),":",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Synchronous: Blocking, immediate response (REST)."),(0,s.kt)("li",{parentName:"ul"},"Asynchronous: Non-blocking, event-driven (Kafka)."))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Resiliency Patterns"),": Enhance fault tolerance with strategies like circuit breaking, retries, and load management.")))}m.isMDXComponent=!0}}]);