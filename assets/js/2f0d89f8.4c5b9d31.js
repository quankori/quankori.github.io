"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6542],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3538:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={title:"Node.js Concept"},i=void 0,s={unversionedId:"programming/nodejs/concept",id:"programming/nodejs/concept",title:"Node.js Concept",description:"Node.js structure",source:"@site/docs/programming/nodejs/concept.md",sourceDirName:"programming/nodejs",slug:"/programming/nodejs/concept",permalink:"/docs/programming/nodejs/concept",draft:!1,tags:[],version:"current",frontMatter:{title:"Node.js Concept"},sidebar:"programming",previous:{title:"Singleton Pattern",permalink:"/docs/programming/pattern/singleton"},next:{title:"Process and Thread",permalink:"/docs/programming/nodejs/process-thread"}},l={},c=[{value:"Node.js structure",id:"nodejs-structure",level:2},{value:"Node.js Fundamentals",id:"nodejs-fundamentals",level:2},{value:"Single-threaded vs Multi-threaded",id:"single-threaded-vs-multi-threaded",level:2},{value:"1. Concurrency Model:",id:"1-concurrency-model",level:3},{value:"2. Memory Consumption:",id:"2-memory-consumption",level:3},{value:"3. Complexity:",id:"3-complexity",level:3},{value:"4. Scalability:",id:"4-scalability",level:3},{value:"Event loop",id:"event-loop",level:2},{value:"process.nextTick() and setImmediate() in Event Loop",id:"processnexttick-and-setimmediate-in-event-loop",level:2},{value:"process.nextTick()",id:"processnexttick",level:3},{value:"setImmediate()",id:"setimmediate",level:3},{value:"Side Effects",id:"side-effects",level:2},{value:"State Mutation",id:"state-mutation",level:2}],u={toc:c},d="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"nodejs-structure"},"Node.js structure"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"V8 is used to interpret and execute Javascript code"),(0,r.kt)("li",{parentName:"ul"},"Libuv is used for accessing the filesystem and some aspects of concurrency")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/quankori/quankori.github.io/master/src/images/programming/3.PNG",alt:"Image"})),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/quankori/quankori.github.io/master/src/images/programming/4.PNG",alt:"Image"})),(0,r.kt)("h2",{id:"nodejs-fundamentals"},"Node.js Fundamentals"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Event Loop & Non-Blocking I/O"),": Node.js achieves high concurrency using an event loop paired with non-blocking I/O. While JavaScript code runs on a single thread, many operations, especially I/O, are offloaded, allowing the main thread to process other tasks without waiting. This mechanism makes Node.js efficient for I/O-bound applications."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Worker Threads"),': Node.js introduced the "worker_threads" module from version 10.5.0, which provides the ability to run JavaScript in parallel threads, enhancing its capability to handle CPU-bound tasks.')),(0,r.kt)("h2",{id:"single-threaded-vs-multi-threaded"},"Single-threaded vs Multi-threaded"),(0,r.kt)("h3",{id:"1-concurrency-model"},"1. Concurrency Model:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Node.js (Single-threaded)"),": Relies on an event-driven, non-blocking I/O model, suitable for I/O-bound tasks. CPU-bound tasks can pose a challenge unless using worker threads or clustering."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Other Languages (Multi-threaded)"),": Languages like Java or C# use multi-threading, which caters efficiently to both I/O-bound and CPU-bound tasks. However, they introduce challenges such as thread synchronization and potential deadlocks.")),(0,r.kt)("h3",{id:"2-memory-consumption"},"2. Memory Consumption:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Node.js"),": Typically lower since there's no need for multiple threads per connection. Yet, one must ensure the event loop isn't blocked to maintain performance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Multi-threaded Languages"),": Might have a higher footprint as each thread maintains its own stack, but can distribute CPU-bound tasks effectively.")),(0,r.kt)("h3",{id:"3-complexity"},"3. Complexity:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Node.js"),": Generally simpler in terms of concurrency management. One doesn't have to manage thread synchronization in most scenarios. The primary concern is to avoid blocking the event loop."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Multi-threaded Languages"),": Can be complex due to explicit thread management, synchronization issues, and potential deadlocks.")),(0,r.kt)("h3",{id:"4-scalability"},"4. Scalability:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Node.js"),": Scales horizontally by adding more instances. Achievable through tools like the cluster module or container orchestration utilities."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Multi-threaded Languages"),": Can scale both vertically (adding threads) and horizontally (adding machines).")),(0,r.kt)("p",null,'Node.js can indeed operate in a multi-threaded fashion with the "worker_threads" module. However, its primary design is single-threaded. Implementing multiple threads in Node.js brings forth the challenges typical of multi-threaded programming in other languages.'),(0,r.kt)("h2",{id:"event-loop"},"Event loop"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When an asynchronous request is sent, such as an HTTP request, Node.js does not wait for that request to complete before continuing to execute other requests. Instead, Node.js sends that request to the system and continues to execute other requests. When that request is completed, the system notifies Node.js that the request is complete, and Node.js continues to execute other tasks.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Tasks in the event loop are queued in different queues, including:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Task queue (also known as a callback queue): Contains callback functions called when an asynchronous request ends.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Microtask queue: Contains callback functions called when a promise is resolved or rejected.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Timers queue: Contains callback functions called when a time or timer (timeout or interval) is activated.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When the event loop starts, it executes tasks in the microtask queue first, then the task queue, and finally the timers queue.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When a task is executed, Node.js puts it into an infinite loop to wait for other tasks. While waiting, Node.js continues to execute tasks in the event loop queue."))),(0,r.kt)("h2",{id:"processnexttick-and-setimmediate-in-event-loop"},"process.nextTick() and setImmediate() in Event Loop"),(0,r.kt)("p",null,"In Node.js, both process.nextTick() and setImmediate() are used to schedule the execution of a callback function after the current phase of the event loop completes. However, they operate in different parts of the loop."),(0,r.kt)("h3",{id:"processnexttick"},"process.nextTick()"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description"),": Schedules a callback to be invoked after the current phase of the event loop completes and before any other I/O operations occur."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Operation"),': The callback is added to a special queue called the "nextTick queue," and will be executed after each phase of the event loop. This means that if you keep adding functions to the "nextTick queue," the event loop can get stuck in the current phase, and other operations (like I/O) may be delayed.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'console.log("Start");\n\nprocess.nextTick(() => {\n  console.log("Next Tick");\n});\n\nconsole.log("End");\n')),(0,r.kt)("p",null,"Output"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"Start\nEnd\nNext Tick\n")),(0,r.kt)("h3",{id:"setimmediate"},"setImmediate()"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description"),': Schedules a callback to be executed in the "check" phase of the event loop after I/O events are processed.'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Operation"),": The callback is added to a separate queue and will be executed after all I/O events are processed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'console.log("Start");\n\nsetImmediate(() => {\n  console.log("Immediate");\n});\n\nconsole.log("End");\n')),(0,r.kt)("p",null,"Output"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"Start;\nEnd;\nImmediate;\n")),(0,r.kt)("p",null,"However, the order between Next Tick and Immediate is not guaranteed in every scenario, especially when they're invoked from within an I/O cycle. But if run in a context with no I/O, process.nextTick() will always execute before setImmediate()."),(0,r.kt)("p",null,"In practice, when you need to schedule a function to run after the current stack completes but before any I/O operations, use process.nextTick(). When you want to schedule a function to run after all I/O operations, use setImmediate()."),(0,r.kt)("h2",{id:"side-effects"},"Side Effects"),(0,r.kt)("p",null,"A side effect refers to any observable change in the system that is caused by executing a function, other than the value it returns. This could be anything from changing a global variable, making a network request, manipulating the DOM, writing to a file, or printing to the console, among others."),(0,r.kt)("p",null,"Side effects are not inherently bad and are often necessary (e.g., we need side effects to update a user interface or save data to a database). However, functions with side effects are typically harder to test, debug, and reason about than pure functions, which have no side effects."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let counter: number = 0;\nfunction increment(): void {\n  counter++; // This is a side effect as it modifies an external variable.\n}\n")),(0,r.kt)("h2",{id:"state-mutation"},"State Mutation"),(0,r.kt)("p",null,"State mutation refers to the direct modification or change of a data structure's state. In languages like JavaScript and TypeScript, objects and arrays are mutable by default, meaning their properties and elements can be changed directly after they're created."),(0,r.kt)("p",null,"State mutation can lead to unpredictable behavior, especially in larger applications or when using certain programming paradigms like functional programming. This is why libraries like Redux emphasize the importance of treating state as immutable and making changes through copies rather than direct mutations."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'interface User {\n  name: string;\n  age: number;\n}\n\nconst user: User = {\n  name: "Alice",\n  age: 25,\n};\n\nuser.age = 26; // This is a state mutation.\n')))}p.isMDXComponent=!0}}]);