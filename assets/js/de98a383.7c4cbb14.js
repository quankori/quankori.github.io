"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1393],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>g});var o=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=o.createContext({}),s=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=s(e.components);return o.createElement(l.Provider,{value:n},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),m=s(t),d=r,g=m["".concat(l,".").concat(d)]||m[d]||p[d]||i;return t?o.createElement(g,a(a({ref:n},u),{},{components:t})):o.createElement(g,a({ref:n},u))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=d;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c[m]="string"==typeof e?e:r,a[1]=c;for(var s=2;s<i;s++)a[s]=t[s];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},4116:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>c,toc:()=>s});var o=t(7462),r=(t(7294),t(3905));const i={title:"Go Concept"},a=void 0,c={unversionedId:"programming/go/concept",id:"programming/go/concept",title:"Go Concept",description:"Context",source:"@site/docs/programming/go/concept.md",sourceDirName:"programming/go",slug:"/programming/go/concept",permalink:"/docs/programming/go/concept",draft:!1,tags:[],version:"current",frontMatter:{title:"Go Concept"},sidebar:"programming",previous:{title:"SOLID Principle",permalink:"/docs/programming/concept/solid"},next:{title:"Node.js Concept",permalink:"/docs/programming/nodejs/concept"}},l={},s=[{value:"Context",id:"context",level:2},{value:"Goroutine",id:"goroutine",level:2},{value:"Channel",id:"channel",level:2},{value:"Mutex",id:"mutex",level:2}],u={toc:s},m="wrapper";function p(e){let{components:n,...t}=e;return(0,r.kt)(m,(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"context"},"Context"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The Context is a mechanism in Golang used to manage concurrent tasks and to control the execution and termination of goroutines. It can be utilized to transmit information and control concurrent tasks, helping manage resources and prevent tasks from running for too long.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"There are three primary Context types in Golang:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Background"),": The default Context used to initiate a new Context."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"TODO"),": Used to handle simple and temporary tasks."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"WithCancel"),": Allows a task to be cancelled once its Context has expired."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"WithDeadline"),": Allows setting a deadline for a task. Once the deadline is reached, the Context will automatically cancel the task."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"WithTimeout"),": Sets an execution time limit for a task. Once this time is up, the Context will automatically cancel the task."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Without correctly implementing Context, goroutines might get blocked or might not be properly cancelled. This can lead to resource wastage, decreased application performance, and potential security issues. Therefore, using Context is crucial when developing multi-threaded applications to ensure their correctness and safety."))),(0,r.kt)("h2",{id:"goroutine"},"Goroutine"),(0,r.kt)("p",null,"Goroutines provide a means to execute tasks concurrently, enhancing the efficiency of an application. When you need to perform tasks concurrently without waiting for a previous task to finish, Goroutines are an excellent choice."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func numbers() {\n    for i := 1; i <= 5; i++ {\n        time.Sleep(250 * time.Millisecond)\n        fmt.Printf("%d ", i)\n    }\n}\nfunc alphabets() {\n    for i := \'a\'; i <= \'e\'; i++ {\n        time.Sleep(400 * time.Millisecond)\n        fmt.Printf("%c ", i)\n    }\n}\n\n// Goroutines func\nfunc goroutines() {\n    go numbers()\n    go alphabets()\n    time.Sleep(3000 * time.Millisecond)\n    fmt.Println("main terminated")\n}\n')),(0,r.kt)("h2",{id:"channel"},"Channel"),(0,r.kt)("p",null,"A Channel is a mechanism used to transfer data between Goroutines. It is used to synchronize access to data among Goroutines. When you need to send data between Goroutines without facing problems like deadlocks or race conditions, or when you wish to synchronize concurrent tasks, a channel is a highly useful tool."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func send(c chan int) {\n    for i := 0; i < 5; i++ {\n        fmt.Printf("send %v to channel\\n", i)\n        c <- i // send i to channel\n    }\n}\n\nfunc receive(c chan int) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(1 * time.Millisecond)\n        s := <-c // receive channel\n        fmt.Println(s)\n    }\n}\n\n// Channel func\nfunc channel() {\n    c := make(chan int)\n    go send(c)\n    go receive(c)\n    time.Sleep(100 * time.Millisecond)\n    fmt.Println("end")\n}\n')),(0,r.kt)("h2",{id:"mutex"},"Mutex"),(0,r.kt)("p",null,"Mutex (Mutual Exclusion) is a synchronization mechanism ensuring that only one Goroutine accesses data at any given time, preventing data conflicts when accessed simultaneously by multiple Goroutines. When you need to synchronize data access among Goroutines and ensure data is accessed correctly, Mutex is the right tool."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'\n// Khai b\xe1o m\u1ed9t instance mutex\nvar mu sync.Mutex\n\n//Khai b\xe1o bi\u1ebfn count \u0111\u01b0\u1ee3c truy c\u1eadp b\u1edfi t\u1ea5t c\u1ea3 c\xe1c routine\nvar count = 0\n\n// Sao ch\xe9p count v\xe0o temp, th\u1ef1c hi\u1ec7n m\u1ed9t v\xe0i x\u1eed l\xfd (t\u0103ng d\u1ea7n) v\xe0 l\u01b0u l\u1ea1i v\xe0o count\n// t\u1ea1m d\u1eebng m\u1ed9t kho\u1ea3ng ng\u1eabu nhi\xean \u0111\u01b0\u1ee3c th\xeam v\xe0o gi\u1eefa l\xfac \u0111\u1ecdc v\xe0 ghi count\nfunc process(n int) {\n    //V\xf2ng l\u1eb7p t\u0103ng count 10 l\u1ea7n\n    for i := 0; i < 10; i++ {\n        time.Sleep(time.Duration(rand.Int31n(2)) * time.Second)\n        //B\u1eaft \u0111\u1ea7u kho\xe1 \u1edf \u0111\xe2y\n        mu.Lock()\n        temp := count\n        temp++\n        time.Sleep(time.Duration(rand.Int31n(2)) * time.Second)\n        count = temp\n        // M\u1edf kho\xe1\n        mu.Unlock()\n    }\n    fmt.Println("Count after i="+strconv.Itoa(n)+" Count:", strconv.Itoa(count))\n}\n\n// Mutex func\nfunc mutex() {\n    //l\u1eb7p g\u1ecdi process() 3 l\u1ea7n\n    for i := 1; i < 4; i++ {\n        go process(i)\n    }\n\n    //T\u1ea1m d\u1eebng \u0111\u1ec3 \u0111\u1ee3i cho t\u1ea5t c\u1ea3 routine ho\xe0n th\xe0nh\n    time.Sleep(25 * time.Second)\n    fmt.Println("Final Count:", count)\n}\n')))}p.isMDXComponent=!0}}]);