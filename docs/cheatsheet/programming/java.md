---
title: Java
---

## Core Architecture

**Core architecture**:

- **JVM**: Executes Java bytecode efficiently.
  - **Bytecode execution**: Runs compiled .class files.
  - **JIT compiler**: Optimizes bytecode to machine code at runtime (HotSpot).
  - **Garbage collection**: Manages memory (e.g., G1, ZGC).
- **Class loader**: Loads classes into the JVM.
  - **Bootstrap**: Loads core Java classes.
  - **Extension**: Loads extension classes.
  - **Application**: Loads user-defined classes.
- **Language features**: Core syntax and capabilities.
  - **Object-oriented**: Uses classes and interfaces.
  - **Generics**: Type-safe collections.
  - **Lambdas & streams**: Functional programming features.
  - **Modules**: Modularizes code (Java 9+).

### JVM Service

```java
// src/main/java/com/example/core/JVMService.java (**JVM**)
package com.example.core;

public class JVMService {
    public String executeBytecode(String code) {
        return "Executed: " + code;
    }

    public void triggerGarbageCollection() {
        System.gc();
        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        System.out.println("Total Memory: " + totalMemory + ", Free Memory: " + freeMemory);
    }
}
```

**JVM Service Details**:

- **Purpose**: Simulates JVM bytecode execution and garbage collection triggering.
- **Explanation**: The `executeBytecode` method mimics running a string as bytecode, while `triggerGarbageCollection` suggests a GC run and reports memory usage. `System.gc()` hints at garbage collection, though itâ€™s not guaranteed to execute immediately. Memory stats are fetched using `Runtime`.
- **JVM Details**:
  - **Bytecode Execution**: JVM interprets or compiles `.class` files generated by `javac`.
  - **JIT Compiler (HotSpot)**: Optimizes bytecode to native code at runtime, using profiling to identify frequently executed ("hot") methods.
  - **Garbage Collection**: G1 (Garbage-First) prioritizes regions with most garbage for collection; ZGC offers low-pause times. Triggered by heap pressure or manual suggestion.

### Class Loader Service

```java
// src/main/java/com/example/core/ClassLoaderService.java (**Class loader**)
package com.example.core;

public class ClassLoaderService {
    public String loadClass(String className) {
        ClassLoader classLoader = ClassLoader.getSystemClassLoader();
        try {
            Class<?> clazz = classLoader.loadClass(className);
            return "Loaded: " + clazz.getName();
        } catch (ClassNotFoundException e) {
            return "Class not found: " + className;
        }
    }
}
```

**Class Loader Service Details**:

- **Purpose**: Demonstrates loading a class using the system class loader.
- **Explanation**: The `loadClass` method retrieves the system class loader (Application loader) and attempts to load a class by name, returning its name if successful or an error message if not found.
- **Class Loader Details**:
  - **Bootstrap**: Loads core JDK classes (e.g., `java.lang.Object`) from `rt.jar`.
  - **Extension**: Loads classes from `jre/lib/ext` directory.
  - **Application**: Loads user-defined classes from the classpath.

### Language Features Service

```java
// src/main/java/com/example/core/LanguageFeaturesService.java (**Language features**)
package com.example.core;

import java.util.Arrays;
import java.util.List;

public class LanguageFeaturesService {
    public <T> List<T> createGenericList(T item) {
        return Arrays.asList(item);
    }

    public String useLambdaAndStream(List<Integer> numbers) {
        return numbers.stream()
                      .filter(n -> n > 0)
                      .map(String::valueOf)
                      .reduce("", String::concat);
    }
}
```

**Language Features Service Details**:

- **Purpose**: Showcases generics and lambdas/streams in Java.
- **Explanation**: `createGenericList` uses generics to create a type-safe list, while `useLambdaAndStream` filters positive numbers from a list, converts them to strings, and concatenates them using stream operations and lambda expressions.
- **Language Features Details**:
  - **Object-oriented**: Classes and interfaces define structure and behavior.
  - **Generics**: Ensures type safety for collections (e.g., `List<String>`).
  - **Lambdas & Streams**: Adds functional programming capabilities (e.g., filtering, mapping).
  - **Modules**: Java 9+ `module-info.java` organizes code into modules (not shown here).

## Performance Optimization

**Performance optimization**:

- **Memory management**: Controls memory allocation.
  - **Heap**: Young/Old generation for objects.
  - **Stack**: Per-thread call stacks.
  - **Tuning JVM**: Adjusts memory with `-Xms`, `-Xmx`.
- **Concurrency**: Handles multi-threading.
  - **Threads & thread pools**: Manages concurrent tasks.
  - **Executors framework**: Simplifies thread management.
  - **Fork/join framework**: Parallelizes tasks.
  - **CompletableFuture**: Async programming.
- **Profiling**: Analyzes performance.
  - **VisualVM**: Monitors JVM metrics.
  - **JProfiler**: Detailed profiling tool.
  - **JMH**: Microbenchmarking framework.
- **JIT optimization**: Enhances runtime performance.
  - **Inlining**: Embeds method calls.
  - **Loop unrolling**: Reduces loop overhead.
  - **Escape analysis**: Optimizes object allocation.

### Memory Service

```java
// src/main/java/com/example/perf/MemoryService.java (**Memory management**)
package com.example.perf;

public class MemoryService {
    public void allocateMemory() {
        Object[] heapObjects = new Object[1000000];
        for (int i = 0; i < heapObjects.length; i++) {
            heapObjects[i] = new Object();
        }
        Runtime runtime = Runtime.getRuntime();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Used memory after allocation: " + usedMemory);
    }
}
```

**Memory Service Details**:

- **Purpose**: Demonstrates heap allocation and memory inspection.
- **Explanation**: Creates a large array on the heap, fills it with objects (Young generation initially), and uses `Runtime` to report memory usage after allocation, showing heap consumption.
- **Memory Management Details**:
  - **Heap**: Split into Young (Eden, Survivor) and Old generations; objects age and move based on GC cycles.
  - **Stack**: Stores method frames and local variables per thread, separate from heap.
  - **Tuning JVM**: `-Xms` sets initial heap size, `-Xmx` sets maximum (e.g., `-Xms512m -Xmx1024m`).

### Concurrency Service

```java
// src/main/java/com/example/perf/ConcurrencyService.java (**Concurrency**)
package com.example.perf;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;

public class ConcurrencyService {
    private ExecutorService executor = Executors.newFixedThreadPool(4);

    public CompletableFuture<String> asyncTask(int id) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            return "Task " + id;
        }, executor);
    }

    public void shutdown() {
        executor.shutdown();
    }
}
```

**Concurrency Service Details**:

- **Purpose**: Implements asynchronous task execution using a thread pool and CompletableFuture.
- **Explanation**: Uses `Executors` to create a fixed thread pool of 4 threads, then `CompletableFuture.supplyAsync` to run a task asynchronously, simulating work with a 1-second sleep, and cleans up with `shutdown`.
- **Concurrency Details**:
  - **Threads & Thread Pools**: `Executors` reuses threads for efficiency.
  - **Executors Framework**: Simplifies thread management (e.g., `newFixedThreadPool`).
  - **Fork/Join**: Not shown but used for recursive task division (e.g., `ForkJoinPool`).
  - **CompletableFuture**: Enables non-blocking async operations.

### Profiling Service

```java
// src/main/java/com/example/perf/ProfilingService.java (**Profiling**)
package com.example.perf;

public class ProfilingService {
    public void profilePerformance() {
        long startTime = System.nanoTime();
        int sum = 0;
        for (int i = 0; i < 1000000; i++) {
            sum += i;
        }
        long endTime = System.nanoTime();
        System.out.println("Execution time (ns): " + (endTime - startTime));
    }
}
```

**Profiling Service Details**:

- **Purpose**: Measures execution time of a simple computation loop.
- **Explanation**: Records start and end times in nanoseconds using `System.nanoTime`, performs a million iterations to sum numbers, and prints the elapsed time for basic profiling.
- **Profiling Details**:
  - **VisualVM**: Monitors JVM metrics like CPU and memory usage.
  - **JProfiler**: Offers detailed call graphs and memory analysis.
  - **JMH**: Provides precise microbenchmarking (e.g., via `java -jar benchmarks.jar`).

### JIT Optimization Service

```java
// src/main/java/com/example/perf/JITOptimizationService.java (**JIT optimization**)
package com.example.perf;

public class JITOptimizationService {
    public int optimizeLoop(int n) {
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += i;
        }
        return sum;
    }
}
```

**JIT Optimization Service Details**:

- **Purpose**: Demonstrates a loop that the JIT compiler can optimize.
- **Explanation**: A simple loop adds numbers up to `n`; the JIT compiler (HotSpot) may inline this method, unroll the loop, or apply escape analysis to optimize object allocation during runtime.
- **JIT Optimization Details**:
  - **Inlining**: Replaces method calls with their bodies (e.g., `sum += i` directly).
  - **Loop Unrolling**: Reduces iterations by expanding loop body (e.g., `sum += i; sum += i+1;`).
  - **Escape Analysis**: Determines if objects escape method scope; if not, allocates on stack.

---

## Scaling

**Scaling**:

- **Horizontal scaling**: Adds more instances.
  - **Load balancer**: Uses Spring Cloud for distribution.
  - **Microservices**: Deploys with Spring Boot.
- **Vertical scaling**: Enhances single instance.
  - **JVM tuning**: Adjusts memory and threads.
  - **Thread pool optimization**: Balances concurrency.
- **Distributed systems**: Scales across nodes.
  - **Messaging**: Integrates Kafka or RabbitMQ.
  - **Clustering**: Uses Hazelcast for data sharing.
  - **Service discovery**: Locates services dynamically.

## Scope Details

- **Global Scope**: Static fields or variables outside methods/classes (e.g., `public static int x;`).
- **Closure Scope**: Simulated with lambdas capturing variables (e.g., `int x = 1; Runnable r = () -> System.out.println(x);`).
- **Class Scope**: Instance or static fields within a class (e.g., `private int y;`).
- **Method Scope**: Local variables within a method (e.g., `int z = 1;`).
- **Block Scope**: Variables within `{}` blocks (e.g., `for (int i = 0; i < 10; i++) {}`).
