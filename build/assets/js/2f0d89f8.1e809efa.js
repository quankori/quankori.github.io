"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6542],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>h});var n=r(7294);function s(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){s(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,s=function(e,t){if(null==e)return{};var r,n,s={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(s[r]=e[r]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(s[r]=e[r])}return s}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,s=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=l(r),m=s,h=p["".concat(c,".").concat(m)]||p[m]||d[m]||o;return r?n.createElement(h,a(a({ref:t},u),{},{components:r})):n.createElement(h,a({ref:t},u))}));function h(e,t){var r=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=r.length,a=new Array(o);a[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[p]="string"==typeof e?e:s,a[1]=i;for(var l=2;l<o;l++)a[l]=r[l];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},3538:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var n=r(7462),s=(r(7294),r(3905));const o={title:"Node.js Concept"},a=void 0,i={unversionedId:"programming/nodejs/concept",id:"programming/nodejs/concept",title:"Node.js Concept",description:"Node.js structure",source:"@site/docs/programming/nodejs/concept.md",sourceDirName:"programming/nodejs",slug:"/programming/nodejs/concept",permalink:"/docs/programming/nodejs/concept",draft:!1,editUrl:"https://github.com/recallwei/wiki/tree/main/website/docs/programming/nodejs/concept.md",tags:[],version:"current",frontMatter:{title:"Node.js Concept"},sidebar:"programming",previous:{title:"Go Concept",permalink:"/docs/programming/go/concept"},next:{title:"Basic",permalink:"/docs/programming/bash/basic"}},c={},l=[{value:"Node.js structure",id:"nodejs-structure",level:2},{value:"Basic concepts of Node.js",id:"basic-concepts-of-nodejs",level:2},{value:"Child process",id:"child-process",level:2},{value:"Worker threads",id:"worker-threads",level:2},{value:"Event loop",id:"event-loop",level:2},{value:"Cluster mode",id:"cluster-mode",level:2},{value:"PM2",id:"pm2",level:2},{value:"process.nextTick() v\xe0 setImmediate()",id:"processnexttick-v\xe0-setimmediate",level:2}],u={toc:l},p="wrapper";function d(e){let{components:t,...r}=e;return(0,s.kt)(p,(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"nodejs-structure"},"Node.js structure"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"V8 is used to interpret and execute Javascript code"),(0,s.kt)("li",{parentName:"ul"},"Libuv is used for accessing the filesystem and some aspects of concurrency")),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/quankori/quankori.github.io/main/src/images/programming/3.PNG",alt:"Image"})),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/quankori/quankori.github.io/main/src/images/programming/4.PNG",alt:"Image"})),(0,s.kt)("h2",{id:"basic-concepts-of-nodejs"},"Basic concepts of Node.js"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Node.js is single-threaded but still supports multi-threading, such as child processes and worker threads.")),(0,s.kt)("h2",{id:"child-process"},"Child process"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Allows you to run a new process on the system and interact with it through pipes. Child processes do not share memory or resources with each other, and each child process uses a separate thread. Child processes are useful for tasks that require processing multiple processes, but require interaction between independent processes.")),(0,s.kt)("h2",{id:"worker-threads"},"Worker threads"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Worker threads are a new feature in Node.js 10.5, allowing you to create multiple threads within a single Node.js process. All worker threads share memory and resources with the main thread, but each worker thread runs on a separate thread. Worker threads make it easier to create multithreaded applications in Node.js.")),(0,s.kt)("h2",{id:"event-loop"},"Event loop"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"When an asynchronous request is sent, such as an HTTP request, Node.js does not wait for that request to complete before continuing to execute other requests. Instead, Node.js sends that request to the system and continues to execute other requests. When that request is completed, the system notifies Node.js that the request is complete, and Node.js continues to execute other tasks.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Tasks in the event loop are queued in different queues, including:"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Task queue (also known as a callback queue): Contains callback functions called when an asynchronous request ends.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Microtask queue: Contains callback functions called when a promise is resolved or rejected.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Timers queue: Contains callback functions called when a time or timer (timeout or interval) is activated.")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"When the event loop starts, it executes tasks in the microtask queue first, then the task queue, and finally the timers queue.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"When a task is executed, Node.js puts it into an infinite loop to wait for other tasks. While waiting, Node.js continues to execute tasks in the event loop queue."))),(0,s.kt)("h2",{id:"cluster-mode"},"Cluster mode"),(0,s.kt)("p",null,"Cluster mode is a feature in Node.js that allows you to create multiple child processes to run the same Node.js application on a computer or network. Each child process can run on a separate CPU or core, so it can take advantage of the power of CPUs or cores in the system."),(0,s.kt)("p",null,"In Cluster mode, the master process is responsible for creating and managing the worker processes. The master process shares TCP and UDP connections with the worker processes, allowing them to share network connections and process requests concurrently. When a request is received, the master process distributes the request to one of the available worker processes."),(0,s.kt)("h2",{id:"pm2"},"PM2"),(0,s.kt)("p",null,"PM2 (Process Manager 2) is a process management tool for Node.js that provides many useful features for running and managing Node.js applications on a server or in a production environment. PM2 can help manage Node.js processes, restart processes that have crashed, monitor system resources, log events, and much more."),(0,s.kt)("h2",{id:"processnexttick-v\xe0-setimmediate"},"process.nextTick() v\xe0 setImmediate()"),(0,s.kt)("p",null,"process.nextTick() and setImmediate() are both methods used for scheduling callbacks. The difference between them is that process.nextTick() is called immediately after the current function ends, while setImmediate() is called after the system has processed all scheduled I/O. Therefore, process.nextTick() may be prioritized in cases where a quick response is necessary and I/O blocking should be avoided."))}d.isMDXComponent=!0}}]);